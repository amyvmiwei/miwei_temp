/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Client_TYPES_H
#define Client_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace Hypertable { namespace ThriftGen {

struct ColumnPredicateOperation {
  enum type {
    EXACT_MATCH = 1,
    PREFIX_MATCH = 2,
    REGEX_MATCH = 4,
    VALUE_MATCH = 7,
    QUALIFIER_EXACT_MATCH = 256,
    QUALIFIER_PREFIX_MATCH = 512,
    QUALIFIER_REGEX_MATCH = 1024,
    QUALIFIER_MATCH = 1792
  };
};

extern const std::map<int, const char*> _ColumnPredicateOperation_VALUES_TO_NAMES;

struct KeyFlag {
  enum type {
    DELETE_ROW = 0,
    DELETE_CF = 1,
    DELETE_CELL = 2,
    DELETE_CELL_VERSION = 3,
    INSERT = 255
  };
};

extern const std::map<int, const char*> _KeyFlag_VALUES_TO_NAMES;

struct MutatorFlag {
  enum type {
    NO_LOG_SYNC = 1,
    IGNORE_UNKNOWN_CFS = 2
  };
};

extern const std::map<int, const char*> _MutatorFlag_VALUES_TO_NAMES;

typedef int64_t Future;

typedef int64_t Namespace;

typedef int64_t Scanner;

typedef int64_t ScannerAsync;

typedef int64_t Mutator;

typedef int64_t MutatorAsync;

typedef std::string Value;

typedef std::vector<std::string>  CellAsArray;

typedef std::string CellsSerialized;

class RowInterval;

class CellInterval;

class ColumnPredicate;

class ScanSpec;

class Key;

class MutateSpec;

class Cell;

class Result;

class ResultAsArrays;

class ResultSerialized;

class NamespaceListing;

class TableSplit;

class ColumnFamilyOptions;

class ColumnFamilySpec;

class AccessGroupOptions;

class AccessGroupSpec;

class Schema;

class ClientException;

typedef struct _RowInterval__isset {
  _RowInterval__isset() : start_row(false), start_inclusive(true), end_row(false), end_inclusive(true) {}
  bool start_row;
  bool start_inclusive;
  bool end_row;
  bool end_inclusive;
} _RowInterval__isset;

class RowInterval {
 public:

  static const char* ascii_fingerprint; // = "E1A4BCD94F003EFF8636F1C98591705A";
  static const uint8_t binary_fingerprint[16]; // = {0xE1,0xA4,0xBC,0xD9,0x4F,0x00,0x3E,0xFF,0x86,0x36,0xF1,0xC9,0x85,0x91,0x70,0x5A};

  RowInterval(const RowInterval&);
  RowInterval& operator=(const RowInterval&);
  RowInterval() : start_row(), start_inclusive(true), end_row(), end_inclusive(true) {
  }

  virtual ~RowInterval() throw();
  std::string start_row;
  bool start_inclusive;
  std::string end_row;
  bool end_inclusive;

  _RowInterval__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_start_inclusive(const bool val);

  void __set_end_row(const std::string& val);

  void __set_end_inclusive(const bool val);

  bool operator == (const RowInterval & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.start_inclusive != rhs.__isset.start_inclusive)
      return false;
    else if (__isset.start_inclusive && !(start_inclusive == rhs.start_inclusive))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.end_inclusive != rhs.__isset.end_inclusive)
      return false;
    else if (__isset.end_inclusive && !(end_inclusive == rhs.end_inclusive))
      return false;
    return true;
  }
  bool operator != (const RowInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RowInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RowInterval &a, RowInterval &b);

typedef struct _CellInterval__isset {
  _CellInterval__isset() : start_row(false), start_column(false), start_inclusive(true), end_row(false), end_column(false), end_inclusive(true) {}
  bool start_row;
  bool start_column;
  bool start_inclusive;
  bool end_row;
  bool end_column;
  bool end_inclusive;
} _CellInterval__isset;

class CellInterval {
 public:

  static const char* ascii_fingerprint; // = "D8C6D6FAE68BF8B6CA0EB2AB01E82C6C";
  static const uint8_t binary_fingerprint[16]; // = {0xD8,0xC6,0xD6,0xFA,0xE6,0x8B,0xF8,0xB6,0xCA,0x0E,0xB2,0xAB,0x01,0xE8,0x2C,0x6C};

  CellInterval(const CellInterval&);
  CellInterval& operator=(const CellInterval&);
  CellInterval() : start_row(), start_column(), start_inclusive(true), end_row(), end_column(), end_inclusive(true) {
  }

  virtual ~CellInterval() throw();
  std::string start_row;
  std::string start_column;
  bool start_inclusive;
  std::string end_row;
  std::string end_column;
  bool end_inclusive;

  _CellInterval__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_start_column(const std::string& val);

  void __set_start_inclusive(const bool val);

  void __set_end_row(const std::string& val);

  void __set_end_column(const std::string& val);

  void __set_end_inclusive(const bool val);

  bool operator == (const CellInterval & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.start_column != rhs.__isset.start_column)
      return false;
    else if (__isset.start_column && !(start_column == rhs.start_column))
      return false;
    if (__isset.start_inclusive != rhs.__isset.start_inclusive)
      return false;
    else if (__isset.start_inclusive && !(start_inclusive == rhs.start_inclusive))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.end_column != rhs.__isset.end_column)
      return false;
    else if (__isset.end_column && !(end_column == rhs.end_column))
      return false;
    if (__isset.end_inclusive != rhs.__isset.end_inclusive)
      return false;
    else if (__isset.end_inclusive && !(end_inclusive == rhs.end_inclusive))
      return false;
    return true;
  }
  bool operator != (const CellInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CellInterval &a, CellInterval &b);

typedef struct _ColumnPredicate__isset {
  _ColumnPredicate__isset() : column_family(false), operation(false), value(false), column_qualifier(false) {}
  bool column_family;
  bool operation;
  bool value;
  bool column_qualifier;
} _ColumnPredicate__isset;

class ColumnPredicate {
 public:

  static const char* ascii_fingerprint; // = "5E0D6E56B1DF2285E40B070B2E5E5E6E";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0x0D,0x6E,0x56,0xB1,0xDF,0x22,0x85,0xE4,0x0B,0x07,0x0B,0x2E,0x5E,0x5E,0x6E};

  ColumnPredicate(const ColumnPredicate&);
  ColumnPredicate& operator=(const ColumnPredicate&);
  ColumnPredicate() : column_family(), operation((ColumnPredicateOperation::type)0), value(), column_qualifier() {
  }

  virtual ~ColumnPredicate() throw();
  std::string column_family;
  ColumnPredicateOperation::type operation;
  std::string value;
  std::string column_qualifier;

  _ColumnPredicate__isset __isset;

  void __set_column_family(const std::string& val);

  void __set_operation(const ColumnPredicateOperation::type val);

  void __set_value(const std::string& val);

  void __set_column_qualifier(const std::string& val);

  bool operator == (const ColumnPredicate & rhs) const
  {
    if (__isset.column_family != rhs.__isset.column_family)
      return false;
    else if (__isset.column_family && !(column_family == rhs.column_family))
      return false;
    if (!(operation == rhs.operation))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.column_qualifier != rhs.__isset.column_qualifier)
      return false;
    else if (__isset.column_qualifier && !(column_qualifier == rhs.column_qualifier))
      return false;
    return true;
  }
  bool operator != (const ColumnPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnPredicate &a, ColumnPredicate &b);

typedef struct _ScanSpec__isset {
  _ScanSpec__isset() : row_intervals(false), cell_intervals(false), return_deletes(true), versions(true), row_limit(true), start_time(false), end_time(false), columns(false), keys_only(true), cell_limit(true), cell_limit_per_family(true), row_regexp(false), value_regexp(false), scan_and_filter_rows(true), row_offset(true), cell_offset(true), column_predicates(false), do_not_cache(true) {}
  bool row_intervals;
  bool cell_intervals;
  bool return_deletes;
  bool versions;
  bool row_limit;
  bool start_time;
  bool end_time;
  bool columns;
  bool keys_only;
  bool cell_limit;
  bool cell_limit_per_family;
  bool row_regexp;
  bool value_regexp;
  bool scan_and_filter_rows;
  bool row_offset;
  bool cell_offset;
  bool column_predicates;
  bool do_not_cache;
} _ScanSpec__isset;

class ScanSpec {
 public:

  static const char* ascii_fingerprint; // = "CAB903AC8C5C4847373DE9F201D35C02";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0xB9,0x03,0xAC,0x8C,0x5C,0x48,0x47,0x37,0x3D,0xE9,0xF2,0x01,0xD3,0x5C,0x02};

  ScanSpec(const ScanSpec&);
  ScanSpec& operator=(const ScanSpec&);
  ScanSpec() : return_deletes(false), versions(0), row_limit(0), start_time(0), end_time(0), keys_only(false), cell_limit(0), cell_limit_per_family(0), row_regexp(), value_regexp(), scan_and_filter_rows(false), row_offset(0), cell_offset(0), do_not_cache(false) {
  }

  virtual ~ScanSpec() throw();
  std::vector<RowInterval>  row_intervals;
  std::vector<CellInterval>  cell_intervals;
  bool return_deletes;
  int32_t versions;
  int32_t row_limit;
  int64_t start_time;
  int64_t end_time;
  std::vector<std::string>  columns;
  bool keys_only;
  int32_t cell_limit;
  int32_t cell_limit_per_family;
  std::string row_regexp;
  std::string value_regexp;
  bool scan_and_filter_rows;
  int32_t row_offset;
  int32_t cell_offset;
  std::vector<ColumnPredicate>  column_predicates;
  bool do_not_cache;

  _ScanSpec__isset __isset;

  void __set_row_intervals(const std::vector<RowInterval> & val);

  void __set_cell_intervals(const std::vector<CellInterval> & val);

  void __set_return_deletes(const bool val);

  void __set_versions(const int32_t val);

  void __set_row_limit(const int32_t val);

  void __set_start_time(const int64_t val);

  void __set_end_time(const int64_t val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_keys_only(const bool val);

  void __set_cell_limit(const int32_t val);

  void __set_cell_limit_per_family(const int32_t val);

  void __set_row_regexp(const std::string& val);

  void __set_value_regexp(const std::string& val);

  void __set_scan_and_filter_rows(const bool val);

  void __set_row_offset(const int32_t val);

  void __set_cell_offset(const int32_t val);

  void __set_column_predicates(const std::vector<ColumnPredicate> & val);

  void __set_do_not_cache(const bool val);

  bool operator == (const ScanSpec & rhs) const
  {
    if (__isset.row_intervals != rhs.__isset.row_intervals)
      return false;
    else if (__isset.row_intervals && !(row_intervals == rhs.row_intervals))
      return false;
    if (__isset.cell_intervals != rhs.__isset.cell_intervals)
      return false;
    else if (__isset.cell_intervals && !(cell_intervals == rhs.cell_intervals))
      return false;
    if (__isset.return_deletes != rhs.__isset.return_deletes)
      return false;
    else if (__isset.return_deletes && !(return_deletes == rhs.return_deletes))
      return false;
    if (__isset.versions != rhs.__isset.versions)
      return false;
    else if (__isset.versions && !(versions == rhs.versions))
      return false;
    if (__isset.row_limit != rhs.__isset.row_limit)
      return false;
    else if (__isset.row_limit && !(row_limit == rhs.row_limit))
      return false;
    if (__isset.start_time != rhs.__isset.start_time)
      return false;
    else if (__isset.start_time && !(start_time == rhs.start_time))
      return false;
    if (__isset.end_time != rhs.__isset.end_time)
      return false;
    else if (__isset.end_time && !(end_time == rhs.end_time))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.keys_only != rhs.__isset.keys_only)
      return false;
    else if (__isset.keys_only && !(keys_only == rhs.keys_only))
      return false;
    if (__isset.cell_limit != rhs.__isset.cell_limit)
      return false;
    else if (__isset.cell_limit && !(cell_limit == rhs.cell_limit))
      return false;
    if (__isset.cell_limit_per_family != rhs.__isset.cell_limit_per_family)
      return false;
    else if (__isset.cell_limit_per_family && !(cell_limit_per_family == rhs.cell_limit_per_family))
      return false;
    if (__isset.row_regexp != rhs.__isset.row_regexp)
      return false;
    else if (__isset.row_regexp && !(row_regexp == rhs.row_regexp))
      return false;
    if (__isset.value_regexp != rhs.__isset.value_regexp)
      return false;
    else if (__isset.value_regexp && !(value_regexp == rhs.value_regexp))
      return false;
    if (__isset.scan_and_filter_rows != rhs.__isset.scan_and_filter_rows)
      return false;
    else if (__isset.scan_and_filter_rows && !(scan_and_filter_rows == rhs.scan_and_filter_rows))
      return false;
    if (__isset.row_offset != rhs.__isset.row_offset)
      return false;
    else if (__isset.row_offset && !(row_offset == rhs.row_offset))
      return false;
    if (__isset.cell_offset != rhs.__isset.cell_offset)
      return false;
    else if (__isset.cell_offset && !(cell_offset == rhs.cell_offset))
      return false;
    if (__isset.column_predicates != rhs.__isset.column_predicates)
      return false;
    else if (__isset.column_predicates && !(column_predicates == rhs.column_predicates))
      return false;
    if (__isset.do_not_cache != rhs.__isset.do_not_cache)
      return false;
    else if (__isset.do_not_cache && !(do_not_cache == rhs.do_not_cache))
      return false;
    return true;
  }
  bool operator != (const ScanSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScanSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ScanSpec &a, ScanSpec &b);

typedef struct _Key__isset {
  _Key__isset() : row(false), column_family(false), column_qualifier(false), timestamp(false), revision(false), flag(true) {}
  bool row;
  bool column_family;
  bool column_qualifier;
  bool timestamp;
  bool revision;
  bool flag;
} _Key__isset;

class Key {
 public:

  static const char* ascii_fingerprint; // = "17134A3D4B5435B7D4FA71A5B3905382";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x13,0x4A,0x3D,0x4B,0x54,0x35,0xB7,0xD4,0xFA,0x71,0xA5,0xB3,0x90,0x53,0x82};

  Key(const Key&);
  Key& operator=(const Key&);
  Key() : row(), column_family(), column_qualifier(), timestamp(0), revision(0), flag((KeyFlag::type)255) {
    flag = (KeyFlag::type)255;

  }

  virtual ~Key() throw();
  std::string row;
  std::string column_family;
  std::string column_qualifier;
  int64_t timestamp;
  int64_t revision;
  KeyFlag::type flag;

  _Key__isset __isset;

  void __set_row(const std::string& val);

  void __set_column_family(const std::string& val);

  void __set_column_qualifier(const std::string& val);

  void __set_timestamp(const int64_t val);

  void __set_revision(const int64_t val);

  void __set_flag(const KeyFlag::type val);

  bool operator == (const Key & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(column_family == rhs.column_family))
      return false;
    if (!(column_qualifier == rhs.column_qualifier))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.revision != rhs.__isset.revision)
      return false;
    else if (__isset.revision && !(revision == rhs.revision))
      return false;
    if (!(flag == rhs.flag))
      return false;
    return true;
  }
  bool operator != (const Key &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Key & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Key &a, Key &b);


class MutateSpec {
 public:

  static const char* ascii_fingerprint; // = "28C2ECC89260BADB9C70330FBF47BFA8";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

  MutateSpec(const MutateSpec&);
  MutateSpec& operator=(const MutateSpec&);
  MutateSpec() : appname(""), flush_interval(1000), flags(2) {
  }

  virtual ~MutateSpec() throw();
  std::string appname;
  int32_t flush_interval;
  int32_t flags;

  void __set_appname(const std::string& val);

  void __set_flush_interval(const int32_t val);

  void __set_flags(const int32_t val);

  bool operator == (const MutateSpec & rhs) const
  {
    if (!(appname == rhs.appname))
      return false;
    if (!(flush_interval == rhs.flush_interval))
      return false;
    if (!(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const MutateSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutateSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MutateSpec &a, MutateSpec &b);

typedef struct _Cell__isset {
  _Cell__isset() : key(false), value(false) {}
  bool key;
  bool value;
} _Cell__isset;

class Cell {
 public:

  static const char* ascii_fingerprint; // = "DC051ACCFBB8C1A7B6D15A530DEBC267";
  static const uint8_t binary_fingerprint[16]; // = {0xDC,0x05,0x1A,0xCC,0xFB,0xB8,0xC1,0xA7,0xB6,0xD1,0x5A,0x53,0x0D,0xEB,0xC2,0x67};

  Cell(const Cell&);
  Cell& operator=(const Cell&);
  Cell() : value() {
  }

  virtual ~Cell() throw();
  Key key;
  Value value;

  _Cell__isset __isset;

  void __set_key(const Key& val);

  void __set_value(const Value& val);

  bool operator == (const Cell & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Cell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Cell &a, Cell &b);

typedef struct _Result__isset {
  _Result__isset() : error(false), error_msg(false), cells(false) {}
  bool error;
  bool error_msg;
  bool cells;
} _Result__isset;

class Result {
 public:

  static const char* ascii_fingerprint; // = "3961071AF9F0CD494C023BDE4BE15710";
  static const uint8_t binary_fingerprint[16]; // = {0x39,0x61,0x07,0x1A,0xF9,0xF0,0xCD,0x49,0x4C,0x02,0x3B,0xDE,0x4B,0xE1,0x57,0x10};

  Result(const Result&);
  Result& operator=(const Result&);
  Result() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg() {
  }

  virtual ~Result() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  std::vector<Cell>  cells;

  _Result__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const Result & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Result &a, Result &b);

typedef struct _ResultAsArrays__isset {
  _ResultAsArrays__isset() : error(false), error_msg(false), cells(false) {}
  bool error;
  bool error_msg;
  bool cells;
} _ResultAsArrays__isset;

class ResultAsArrays {
 public:

  static const char* ascii_fingerprint; // = "E386C86852D0BFBEDC152386E212771F";
  static const uint8_t binary_fingerprint[16]; // = {0xE3,0x86,0xC8,0x68,0x52,0xD0,0xBF,0xBE,0xDC,0x15,0x23,0x86,0xE2,0x12,0x77,0x1F};

  ResultAsArrays(const ResultAsArrays&);
  ResultAsArrays& operator=(const ResultAsArrays&);
  ResultAsArrays() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg() {
  }

  virtual ~ResultAsArrays() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  std::vector<CellAsArray>  cells;

  _ResultAsArrays__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ResultAsArrays & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ResultAsArrays &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultAsArrays & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ResultAsArrays &a, ResultAsArrays &b);

typedef struct _ResultSerialized__isset {
  _ResultSerialized__isset() : error(false), error_msg(false), cells(false) {}
  bool error;
  bool error_msg;
  bool cells;
} _ResultSerialized__isset;

class ResultSerialized {
 public:

  static const char* ascii_fingerprint; // = "8D7BAC5AE63452BB4EA65AE73E2331A7";
  static const uint8_t binary_fingerprint[16]; // = {0x8D,0x7B,0xAC,0x5A,0xE6,0x34,0x52,0xBB,0x4E,0xA6,0x5A,0xE7,0x3E,0x23,0x31,0xA7};

  ResultSerialized(const ResultSerialized&);
  ResultSerialized& operator=(const ResultSerialized&);
  ResultSerialized() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg(), cells() {
  }

  virtual ~ResultSerialized() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  CellsSerialized cells;

  _ResultSerialized__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const CellsSerialized& val);

  bool operator == (const ResultSerialized & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ResultSerialized &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultSerialized & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ResultSerialized &a, ResultSerialized &b);


class NamespaceListing {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  NamespaceListing(const NamespaceListing&);
  NamespaceListing& operator=(const NamespaceListing&);
  NamespaceListing() : name(), is_namespace(0) {
  }

  virtual ~NamespaceListing() throw();
  std::string name;
  bool is_namespace;

  void __set_name(const std::string& val);

  void __set_is_namespace(const bool val);

  bool operator == (const NamespaceListing & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(is_namespace == rhs.is_namespace))
      return false;
    return true;
  }
  bool operator != (const NamespaceListing &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NamespaceListing & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NamespaceListing &a, NamespaceListing &b);

typedef struct _TableSplit__isset {
  _TableSplit__isset() : start_row(false), end_row(false), location(false), ip_address(false), hostname(false) {}
  bool start_row;
  bool end_row;
  bool location;
  bool ip_address;
  bool hostname;
} _TableSplit__isset;

class TableSplit {
 public:

  static const char* ascii_fingerprint; // = "62D6903A20E658BF9EEF263D3451F763";
  static const uint8_t binary_fingerprint[16]; // = {0x62,0xD6,0x90,0x3A,0x20,0xE6,0x58,0xBF,0x9E,0xEF,0x26,0x3D,0x34,0x51,0xF7,0x63};

  TableSplit(const TableSplit&);
  TableSplit& operator=(const TableSplit&);
  TableSplit() : start_row(), end_row(), location(), ip_address(), hostname() {
  }

  virtual ~TableSplit() throw();
  std::string start_row;
  std::string end_row;
  std::string location;
  std::string ip_address;
  std::string hostname;

  _TableSplit__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_end_row(const std::string& val);

  void __set_location(const std::string& val);

  void __set_ip_address(const std::string& val);

  void __set_hostname(const std::string& val);

  bool operator == (const TableSplit & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.ip_address != rhs.__isset.ip_address)
      return false;
    else if (__isset.ip_address && !(ip_address == rhs.ip_address))
      return false;
    if (__isset.hostname != rhs.__isset.hostname)
      return false;
    else if (__isset.hostname && !(hostname == rhs.hostname))
      return false;
    return true;
  }
  bool operator != (const TableSplit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableSplit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TableSplit &a, TableSplit &b);

typedef struct _ColumnFamilyOptions__isset {
  _ColumnFamilyOptions__isset() : max_versions(false), ttl(false), time_order_desc(false), counter(false) {}
  bool max_versions;
  bool ttl;
  bool time_order_desc;
  bool counter;
} _ColumnFamilyOptions__isset;

class ColumnFamilyOptions {
 public:

  static const char* ascii_fingerprint; // = "ACE5CDEF5DC5021F5001821D7845FB8C";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE5,0xCD,0xEF,0x5D,0xC5,0x02,0x1F,0x50,0x01,0x82,0x1D,0x78,0x45,0xFB,0x8C};

  ColumnFamilyOptions(const ColumnFamilyOptions&);
  ColumnFamilyOptions& operator=(const ColumnFamilyOptions&);
  ColumnFamilyOptions() : max_versions(0), ttl(0), time_order_desc(0), counter(0) {
  }

  virtual ~ColumnFamilyOptions() throw();
  int32_t max_versions;
  int32_t ttl;
  bool time_order_desc;
  bool counter;

  _ColumnFamilyOptions__isset __isset;

  void __set_max_versions(const int32_t val);

  void __set_ttl(const int32_t val);

  void __set_time_order_desc(const bool val);

  void __set_counter(const bool val);

  bool operator == (const ColumnFamilyOptions & rhs) const
  {
    if (__isset.max_versions != rhs.__isset.max_versions)
      return false;
    else if (__isset.max_versions && !(max_versions == rhs.max_versions))
      return false;
    if (__isset.ttl != rhs.__isset.ttl)
      return false;
    else if (__isset.ttl && !(ttl == rhs.ttl))
      return false;
    if (__isset.time_order_desc != rhs.__isset.time_order_desc)
      return false;
    else if (__isset.time_order_desc && !(time_order_desc == rhs.time_order_desc))
      return false;
    if (__isset.counter != rhs.__isset.counter)
      return false;
    else if (__isset.counter && !(counter == rhs.counter))
      return false;
    return true;
  }
  bool operator != (const ColumnFamilyOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnFamilyOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnFamilyOptions &a, ColumnFamilyOptions &b);

typedef struct _ColumnFamilySpec__isset {
  _ColumnFamilySpec__isset() : name(false), access_group(false), deleted(false), generation(false), id(false), value_index(false), qualifier_index(false), options(false) {}
  bool name;
  bool access_group;
  bool deleted;
  bool generation;
  bool id;
  bool value_index;
  bool qualifier_index;
  bool options;
} _ColumnFamilySpec__isset;

class ColumnFamilySpec {
 public:

  static const char* ascii_fingerprint; // = "42BC359FA17CBF00292D6912CDDB5034";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xBC,0x35,0x9F,0xA1,0x7C,0xBF,0x00,0x29,0x2D,0x69,0x12,0xCD,0xDB,0x50,0x34};

  ColumnFamilySpec(const ColumnFamilySpec&);
  ColumnFamilySpec& operator=(const ColumnFamilySpec&);
  ColumnFamilySpec() : name(), access_group(), deleted(0), generation(0), id(0), value_index(0), qualifier_index(0) {
  }

  virtual ~ColumnFamilySpec() throw();
  std::string name;
  std::string access_group;
  bool deleted;
  int64_t generation;
  int32_t id;
  bool value_index;
  bool qualifier_index;
  ColumnFamilyOptions options;

  _ColumnFamilySpec__isset __isset;

  void __set_name(const std::string& val);

  void __set_access_group(const std::string& val);

  void __set_deleted(const bool val);

  void __set_generation(const int64_t val);

  void __set_id(const int32_t val);

  void __set_value_index(const bool val);

  void __set_qualifier_index(const bool val);

  void __set_options(const ColumnFamilyOptions& val);

  bool operator == (const ColumnFamilySpec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(access_group == rhs.access_group))
      return false;
    if (!(deleted == rhs.deleted))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (!(value_index == rhs.value_index))
      return false;
    if (!(qualifier_index == rhs.qualifier_index))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const ColumnFamilySpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnFamilySpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnFamilySpec &a, ColumnFamilySpec &b);

typedef struct _AccessGroupOptions__isset {
  _AccessGroupOptions__isset() : replication(false), blocksize(false), compressor(false), bloom_filter(false), in_memory(false) {}
  bool replication;
  bool blocksize;
  bool compressor;
  bool bloom_filter;
  bool in_memory;
} _AccessGroupOptions__isset;

class AccessGroupOptions {
 public:

  static const char* ascii_fingerprint; // = "4346BA357564A572D7812C869630F2AF";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x46,0xBA,0x35,0x75,0x64,0xA5,0x72,0xD7,0x81,0x2C,0x86,0x96,0x30,0xF2,0xAF};

  AccessGroupOptions(const AccessGroupOptions&);
  AccessGroupOptions& operator=(const AccessGroupOptions&);
  AccessGroupOptions() : replication(0), blocksize(0), compressor(), bloom_filter(), in_memory(0) {
  }

  virtual ~AccessGroupOptions() throw();
  int16_t replication;
  int32_t blocksize;
  std::string compressor;
  std::string bloom_filter;
  bool in_memory;

  _AccessGroupOptions__isset __isset;

  void __set_replication(const int16_t val);

  void __set_blocksize(const int32_t val);

  void __set_compressor(const std::string& val);

  void __set_bloom_filter(const std::string& val);

  void __set_in_memory(const bool val);

  bool operator == (const AccessGroupOptions & rhs) const
  {
    if (__isset.replication != rhs.__isset.replication)
      return false;
    else if (__isset.replication && !(replication == rhs.replication))
      return false;
    if (__isset.blocksize != rhs.__isset.blocksize)
      return false;
    else if (__isset.blocksize && !(blocksize == rhs.blocksize))
      return false;
    if (__isset.compressor != rhs.__isset.compressor)
      return false;
    else if (__isset.compressor && !(compressor == rhs.compressor))
      return false;
    if (__isset.bloom_filter != rhs.__isset.bloom_filter)
      return false;
    else if (__isset.bloom_filter && !(bloom_filter == rhs.bloom_filter))
      return false;
    if (__isset.in_memory != rhs.__isset.in_memory)
      return false;
    else if (__isset.in_memory && !(in_memory == rhs.in_memory))
      return false;
    return true;
  }
  bool operator != (const AccessGroupOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccessGroupOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AccessGroupOptions &a, AccessGroupOptions &b);

typedef struct _AccessGroupSpec__isset {
  _AccessGroupSpec__isset() : name(false), generation(false), options(false), defaults(false) {}
  bool name;
  bool generation;
  bool options;
  bool defaults;
} _AccessGroupSpec__isset;

class AccessGroupSpec {
 public:

  static const char* ascii_fingerprint; // = "45567B8B7814C24C13725F0ED4F36F3B";
  static const uint8_t binary_fingerprint[16]; // = {0x45,0x56,0x7B,0x8B,0x78,0x14,0xC2,0x4C,0x13,0x72,0x5F,0x0E,0xD4,0xF3,0x6F,0x3B};

  AccessGroupSpec(const AccessGroupSpec&);
  AccessGroupSpec& operator=(const AccessGroupSpec&);
  AccessGroupSpec() : name(), generation(0) {
  }

  virtual ~AccessGroupSpec() throw();
  std::string name;
  int64_t generation;
  AccessGroupOptions options;
  ColumnFamilyOptions defaults;

  _AccessGroupSpec__isset __isset;

  void __set_name(const std::string& val);

  void __set_generation(const int64_t val);

  void __set_options(const AccessGroupOptions& val);

  void __set_defaults(const ColumnFamilyOptions& val);

  bool operator == (const AccessGroupSpec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.defaults != rhs.__isset.defaults)
      return false;
    else if (__isset.defaults && !(defaults == rhs.defaults))
      return false;
    return true;
  }
  bool operator != (const AccessGroupSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccessGroupSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AccessGroupSpec &a, AccessGroupSpec &b);

typedef struct _Schema__isset {
  _Schema__isset() : access_groups(false), column_families(false), generation(false), version(false), group_commit_interval(false), access_group_defaults(false), column_family_defaults(false) {}
  bool access_groups;
  bool column_families;
  bool generation;
  bool version;
  bool group_commit_interval;
  bool access_group_defaults;
  bool column_family_defaults;
} _Schema__isset;

class Schema {
 public:

  static const char* ascii_fingerprint; // = "CE3A6EFB26C0FEE4181164C929D9051B";
  static const uint8_t binary_fingerprint[16]; // = {0xCE,0x3A,0x6E,0xFB,0x26,0xC0,0xFE,0xE4,0x18,0x11,0x64,0xC9,0x29,0xD9,0x05,0x1B};

  Schema(const Schema&);
  Schema& operator=(const Schema&);
  Schema() : generation(0), version(0), group_commit_interval(0) {
  }

  virtual ~Schema() throw();
  std::map<std::string, AccessGroupSpec>  access_groups;
  std::map<std::string, ColumnFamilySpec>  column_families;
  int64_t generation;
  int32_t version;
  int32_t group_commit_interval;
  AccessGroupOptions access_group_defaults;
  ColumnFamilyOptions column_family_defaults;

  _Schema__isset __isset;

  void __set_access_groups(const std::map<std::string, AccessGroupSpec> & val);

  void __set_column_families(const std::map<std::string, ColumnFamilySpec> & val);

  void __set_generation(const int64_t val);

  void __set_version(const int32_t val);

  void __set_group_commit_interval(const int32_t val);

  void __set_access_group_defaults(const AccessGroupOptions& val);

  void __set_column_family_defaults(const ColumnFamilyOptions& val);

  bool operator == (const Schema & rhs) const
  {
    if (__isset.access_groups != rhs.__isset.access_groups)
      return false;
    else if (__isset.access_groups && !(access_groups == rhs.access_groups))
      return false;
    if (__isset.column_families != rhs.__isset.column_families)
      return false;
    else if (__isset.column_families && !(column_families == rhs.column_families))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.group_commit_interval != rhs.__isset.group_commit_interval)
      return false;
    else if (__isset.group_commit_interval && !(group_commit_interval == rhs.group_commit_interval))
      return false;
    if (__isset.access_group_defaults != rhs.__isset.access_group_defaults)
      return false;
    else if (__isset.access_group_defaults && !(access_group_defaults == rhs.access_group_defaults))
      return false;
    if (__isset.column_family_defaults != rhs.__isset.column_family_defaults)
      return false;
    else if (__isset.column_family_defaults && !(column_family_defaults == rhs.column_family_defaults))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Schema &a, Schema &b);

typedef struct _ClientException__isset {
  _ClientException__isset() : code(false), message(false) {}
  bool code;
  bool message;
} _ClientException__isset;

class ClientException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  ClientException(const ClientException&);
  ClientException& operator=(const ClientException&);
  ClientException() : code(0), message() {
  }

  virtual ~ClientException() throw();
  int32_t code;
  std::string message;

  _ClientException__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const ClientException & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ClientException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClientException &a, ClientException &b);

}} // namespace

#endif
