#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Hypertable::ThriftGen::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hypertable::ThriftGen::ClientService_namespace_create_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_create_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_create_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_create_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_create_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_create_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_create_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_create_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_create_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_create_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_alter_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_alter_table_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_alter_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_alter_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_alter_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_alter_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_alter_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_alter_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_alter_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_alter_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_alter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_alter_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_alter_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_alter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_alter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_alter_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_args->mk_accessors( qw( capacity ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{capacity} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{capacity}) {
      $self->{capacity} = $vals->{capacity};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{capacity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_args');
  if (defined $self->{capacity}) {
    $xfer += $output->writeFieldBegin('capacity', TType::I32, 1);
    $xfer += $output->writeI32($self->{capacity});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_args->mk_accessors( qw( capacity ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{capacity} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{capacity}) {
      $self->{capacity} = $vals->{capacity};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{capacity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_args');
  if (defined $self->{capacity}) {
    $xfer += $output->writeFieldBegin('capacity', TType::I32, 1);
    $xfer += $output->writeI32($self->{capacity});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Result();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Result();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultAsArrays();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultAsArrays();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultSerialized();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultSerialized();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{success} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem79->read($input);
            push(@{$self->{success}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter80 (@{$self->{success}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{success} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem86->read($input);
            push(@{$self->{success}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter87 (@{$self->{success}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size88 = 0;
          $self->{success} = [];
          my $_etype91 = 0;
          $xfer += $input->readListBegin(\$_etype91, \$_size88);
          for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
          {
            my $elem93 = undef;
            {
              my $_size94 = 0;
              $elem93 = [];
              my $_etype97 = 0;
              $xfer += $input->readListBegin(\$_etype97, \$_size94);
              for (my $_i98 = 0; $_i98 < $_size94; ++$_i98)
              {
                my $elem99 = undef;
                $xfer += $input->readString(\$elem99);
                push(@{$elem93},$elem99);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem93);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter100 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter100}}));
            {
              foreach my $iter101 (@{${iter100}}) 
              {
                $xfer += $output->writeString($iter101);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size102 = 0;
          $self->{success} = [];
          my $_etype105 = 0;
          $xfer += $input->readListBegin(\$_etype105, \$_size102);
          for (my $_i106 = 0; $_i106 < $_size102; ++$_i106)
          {
            my $elem107 = undef;
            {
              my $_size108 = 0;
              $elem107 = [];
              my $_etype111 = 0;
              $xfer += $input->readListBegin(\$_etype111, \$_size108);
              for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
              {
                my $elem113 = undef;
                $xfer += $input->readString(\$elem113);
                push(@{$elem107},$elem113);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem107);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter114 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter114}}));
            {
              foreach my $iter115 (@{${iter114}}) 
              {
                $xfer += $output->writeString($iter115);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size116 = 0;
          $self->{success} = [];
          my $_etype119 = 0;
          $xfer += $input->readListBegin(\$_etype119, \$_size116);
          for (my $_i120 = 0; $_i120 < $_size116; ++$_i120)
          {
            my $elem121 = undef;
            $elem121 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem121->read($input);
            push(@{$self->{success}},$elem121);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter122 (@{$self->{success}}) 
        {
          $xfer += ${iter122}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size123 = 0;
          $self->{success} = [];
          my $_etype126 = 0;
          $xfer += $input->readListBegin(\$_etype126, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $elem128 = undef;
            $elem128 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem128->read($input);
            push(@{$self->{success}},$elem128);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter129 (@{$self->{success}}) 
        {
          $xfer += ${iter129}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size130 = 0;
          $self->{success} = [];
          my $_etype133 = 0;
          $xfer += $input->readListBegin(\$_etype133, \$_size130);
          for (my $_i134 = 0; $_i134 < $_size130; ++$_i134)
          {
            my $elem135 = undef;
            {
              my $_size136 = 0;
              $elem135 = [];
              my $_etype139 = 0;
              $xfer += $input->readListBegin(\$_etype139, \$_size136);
              for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
              {
                my $elem141 = undef;
                $xfer += $input->readString(\$elem141);
                push(@{$elem135},$elem141);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem135);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter142 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter142}}));
            {
              foreach my $iter143 (@{${iter142}}) 
              {
                $xfer += $output->writeString($iter143);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size144 = 0;
          $self->{success} = [];
          my $_etype147 = 0;
          $xfer += $input->readListBegin(\$_etype147, \$_size144);
          for (my $_i148 = 0; $_i148 < $_size144; ++$_i148)
          {
            my $elem149 = undef;
            {
              my $_size150 = 0;
              $elem149 = [];
              my $_etype153 = 0;
              $xfer += $input->readListBegin(\$_etype153, \$_size150);
              for (my $_i154 = 0; $_i154 < $_size150; ++$_i154)
              {
                my $elem155 = undef;
                $xfer += $input->readString(\$elem155);
                push(@{$elem149},$elem155);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem149);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter156 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter156}}));
            {
              foreach my $iter157 (@{${iter156}}) 
              {
                $xfer += $output->writeString($iter157);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size158 = 0;
          $self->{success} = [];
          my $_etype161 = 0;
          $xfer += $input->readListBegin(\$_etype161, \$_size158);
          for (my $_i162 = 0; $_i162 < $_size158; ++$_i162)
          {
            my $elem163 = undef;
            $elem163 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem163->read($input);
            push(@{$self->{success}},$elem163);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter164 (@{$self->{success}}) 
        {
          $xfer += ${iter164}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->mk_accessors( qw( ns name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size165 = 0;
          $self->{success} = [];
          my $_etype168 = 0;
          $xfer += $input->readListBegin(\$_etype168, \$_size165);
          for (my $_i169 = 0; $_i169 < $_size165; ++$_i169)
          {
            my $elem170 = undef;
            {
              my $_size171 = 0;
              $elem170 = [];
              my $_etype174 = 0;
              $xfer += $input->readListBegin(\$_etype174, \$_size171);
              for (my $_i175 = 0; $_i175 < $_size171; ++$_i175)
              {
                my $elem176 = undef;
                $xfer += $input->readString(\$elem176);
                push(@{$elem170},$elem176);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem170);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter177 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter177}}));
            {
              foreach my $iter178 (@{${iter177}}) 
              {
                $xfer += $output->writeString($iter178);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_args->mk_accessors( qw( ns table_name row column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 4);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size179 = 0;
          $self->{success} = [];
          my $_etype182 = 0;
          $xfer += $input->readListBegin(\$_etype182, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $elem184 = undef;
            $elem184 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem184->read($input);
            push(@{$self->{success}},$elem184);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter185 (@{$self->{success}}) 
        {
          $xfer += ${iter185}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size186 = 0;
          $self->{success} = [];
          my $_etype189 = 0;
          $xfer += $input->readListBegin(\$_etype189, \$_size186);
          for (my $_i190 = 0; $_i190 < $_size186; ++$_i190)
          {
            my $elem191 = undef;
            {
              my $_size192 = 0;
              $elem191 = [];
              my $_etype195 = 0;
              $xfer += $input->readListBegin(\$_etype195, \$_size192);
              for (my $_i196 = 0; $_i196 < $_size192; ++$_i196)
              {
                my $elem197 = undef;
                $xfer += $input->readString(\$elem197);
                push(@{$elem191},$elem197);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem191);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter198 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter198}}));
            {
              foreach my $iter199 (@{${iter198}}) 
              {
                $xfer += $output->writeString($iter199);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args->mk_accessors( qw( ns table_name mutate_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_refresh_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_refresh_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_refresh_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_refresh_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args->mk_accessors( qw( ns table_name mutate_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size200 = 0;
          $self->{cells} = [];
          my $_etype203 = 0;
          $xfer += $input->readListBegin(\$_etype203, \$_size200);
          for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
          {
            my $elem205 = undef;
            $elem205 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem205->read($input);
            push(@{$self->{cells}},$elem205);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter206 (@{$self->{cells}}) 
        {
          $xfer += ${iter206}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size207 = 0;
          $self->{cells} = [];
          my $_etype210 = 0;
          $xfer += $input->readListBegin(\$_etype210, \$_size207);
          for (my $_i211 = 0; $_i211 < $_size207; ++$_i211)
          {
            my $elem212 = undef;
            $elem212 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem212->read($input);
            push(@{$self->{cells}},$elem212);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter213 (@{$self->{cells}}) 
        {
          $xfer += ${iter213}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size214 = 0;
          $self->{cells} = [];
          my $_etype217 = 0;
          $xfer += $input->readListBegin(\$_etype217, \$_size214);
          for (my $_i218 = 0; $_i218 < $_size214; ++$_i218)
          {
            my $elem219 = undef;
            {
              my $_size220 = 0;
              $elem219 = [];
              my $_etype223 = 0;
              $xfer += $input->readListBegin(\$_etype223, \$_size220);
              for (my $_i224 = 0; $_i224 < $_size220; ++$_i224)
              {
                my $elem225 = undef;
                $xfer += $input->readString(\$elem225);
                push(@{$elem219},$elem225);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem219);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter226 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter226}}));
            {
              foreach my $iter227 (@{${iter226}}) 
              {
                $xfer += $output->writeString($iter227);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size228 = 0;
          $self->{cells} = [];
          my $_etype231 = 0;
          $xfer += $input->readListBegin(\$_etype231, \$_size228);
          for (my $_i232 = 0; $_i232 < $_size228; ++$_i232)
          {
            my $elem233 = undef;
            {
              my $_size234 = 0;
              $elem233 = [];
              my $_etype237 = 0;
              $xfer += $input->readListBegin(\$_etype237, \$_size234);
              for (my $_i238 = 0; $_i238 < $_size234; ++$_i238)
              {
                my $elem239 = undef;
                $xfer += $input->readString(\$elem239);
                push(@{$elem233},$elem239);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem233);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter240 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter240}}));
            {
              foreach my $iter241 (@{${iter240}}) 
              {
                $xfer += $output->writeString($iter241);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 4);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 4);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size242 = 0;
          $self->{cell} = [];
          my $_etype245 = 0;
          $xfer += $input->readListBegin(\$_etype245, \$_size242);
          for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
          {
            my $elem247 = undef;
            $xfer += $input->readString(\$elem247);
            push(@{$self->{cell}},$elem247);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter248 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter248);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size249 = 0;
          $self->{cell} = [];
          my $_etype252 = 0;
          $xfer += $input->readListBegin(\$_etype252, \$_size249);
          for (my $_i253 = 0; $_i253 < $_size249; ++$_i253)
          {
            my $elem254 = undef;
            $xfer += $input->readString(\$elem254);
            push(@{$self->{cell}},$elem254);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter255 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter255);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 3);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size256 = 0;
          $self->{cell} = [];
          my $_etype259 = 0;
          $xfer += $input->readListBegin(\$_etype259, \$_size256);
          for (my $_i260 = 0; $_i260 < $_size256; ++$_i260)
          {
            my $elem261 = undef;
            $xfer += $input->readString(\$elem261);
            push(@{$self->{cell}},$elem261);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter262 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter262);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size263 = 0;
          $self->{cell} = [];
          my $_etype266 = 0;
          $xfer += $input->readListBegin(\$_etype266, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $elem268 = undef;
            $xfer += $input->readString(\$elem268);
            push(@{$self->{cell}},$elem268);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter269 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter269);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size270 = 0;
          $self->{cells} = [];
          my $_etype273 = 0;
          $xfer += $input->readListBegin(\$_etype273, \$_size270);
          for (my $_i274 = 0; $_i274 < $_size270; ++$_i274)
          {
            my $elem275 = undef;
            $elem275 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem275->read($input);
            push(@{$self->{cells}},$elem275);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter276 (@{$self->{cells}}) 
        {
          $xfer += ${iter276}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size277 = 0;
          $self->{cells} = [];
          my $_etype280 = 0;
          $xfer += $input->readListBegin(\$_etype280, \$_size277);
          for (my $_i281 = 0; $_i281 < $_size277; ++$_i281)
          {
            my $elem282 = undef;
            $elem282 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem282->read($input);
            push(@{$self->{cells}},$elem282);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter283 (@{$self->{cells}}) 
        {
          $xfer += ${iter283}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size284 = 0;
          $self->{cells} = [];
          my $_etype287 = 0;
          $xfer += $input->readListBegin(\$_etype287, \$_size284);
          for (my $_i288 = 0; $_i288 < $_size284; ++$_i288)
          {
            my $elem289 = undef;
            {
              my $_size290 = 0;
              $elem289 = [];
              my $_etype293 = 0;
              $xfer += $input->readListBegin(\$_etype293, \$_size290);
              for (my $_i294 = 0; $_i294 < $_size290; ++$_i294)
              {
                my $elem295 = undef;
                $xfer += $input->readString(\$elem295);
                push(@{$elem289},$elem295);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem289);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter296 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter296}}));
            {
              foreach my $iter297 (@{${iter296}}) 
              {
                $xfer += $output->writeString($iter297);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size298 = 0;
          $self->{cells} = [];
          my $_etype301 = 0;
          $xfer += $input->readListBegin(\$_etype301, \$_size298);
          for (my $_i302 = 0; $_i302 < $_size298; ++$_i302)
          {
            my $elem303 = undef;
            {
              my $_size304 = 0;
              $elem303 = [];
              my $_etype307 = 0;
              $xfer += $input->readListBegin(\$_etype307, \$_size304);
              for (my $_i308 = 0; $_i308 < $_size304; ++$_i308)
              {
                my $elem309 = undef;
                $xfer += $input->readString(\$elem309);
                push(@{$elem303},$elem309);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem303);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter310 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter310}}));
            {
              foreach my $iter311 (@{${iter310}}) 
              {
                $xfer += $output->writeString($iter311);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 3);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size312 = 0;
          $self->{cell} = [];
          my $_etype315 = 0;
          $xfer += $input->readListBegin(\$_etype315, \$_size312);
          for (my $_i316 = 0; $_i316 < $_size312; ++$_i316)
          {
            my $elem317 = undef;
            $xfer += $input->readString(\$elem317);
            push(@{$self->{cell}},$elem317);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter318 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter318);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size319 = 0;
          $self->{cell} = [];
          my $_etype322 = 0;
          $xfer += $input->readListBegin(\$_etype322, \$_size319);
          for (my $_i323 = 0; $_i323 < $_size319; ++$_i323)
          {
            my $elem324 = undef;
            $xfer += $input->readString(\$elem324);
            push(@{$self->{cell}},$elem324);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter325 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter325);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size326 = 0;
          $self->{cells} = [];
          my $_etype329 = 0;
          $xfer += $input->readListBegin(\$_etype329, \$_size326);
          for (my $_i330 = 0; $_i330 < $_size326; ++$_i330)
          {
            my $elem331 = undef;
            $elem331 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem331->read($input);
            push(@{$self->{cells}},$elem331);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter332 (@{$self->{cells}}) 
        {
          $xfer += ${iter332}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size333 = 0;
          $self->{cells} = [];
          my $_etype336 = 0;
          $xfer += $input->readListBegin(\$_etype336, \$_size333);
          for (my $_i337 = 0; $_i337 < $_size333; ++$_i337)
          {
            my $elem338 = undef;
            $elem338 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem338->read($input);
            push(@{$self->{cells}},$elem338);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter339 (@{$self->{cells}}) 
        {
          $xfer += ${iter339}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size340 = 0;
          $self->{cells} = [];
          my $_etype343 = 0;
          $xfer += $input->readListBegin(\$_etype343, \$_size340);
          for (my $_i344 = 0; $_i344 < $_size340; ++$_i344)
          {
            my $elem345 = undef;
            {
              my $_size346 = 0;
              $elem345 = [];
              my $_etype349 = 0;
              $xfer += $input->readListBegin(\$_etype349, \$_size346);
              for (my $_i350 = 0; $_i350 < $_size346; ++$_i350)
              {
                my $elem351 = undef;
                $xfer += $input->readString(\$elem351);
                push(@{$elem345},$elem351);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem345);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter352 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter352}}));
            {
              foreach my $iter353 (@{${iter352}}) 
              {
                $xfer += $output->writeString($iter353);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size354 = 0;
          $self->{cells} = [];
          my $_etype357 = 0;
          $xfer += $input->readListBegin(\$_etype357, \$_size354);
          for (my $_i358 = 0; $_i358 < $_size354; ++$_i358)
          {
            my $elem359 = undef;
            {
              my $_size360 = 0;
              $elem359 = [];
              my $_etype363 = 0;
              $xfer += $input->readListBegin(\$_etype363, \$_size360);
              for (my $_i364 = 0; $_i364 < $_size360; ++$_i364)
              {
                my $elem365 = undef;
                $xfer += $input->readString(\$elem365);
                push(@{$elem359},$elem365);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem359);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter366 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter366}}));
            {
              foreach my $iter367 (@{${iter366}}) 
              {
                $xfer += $output->writeString($iter367);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_args->mk_accessors( qw( ns name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_exists_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_exists_args->mk_accessors( qw( ns name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_exists_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_exists_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_id_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_id_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_with_ids_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_with_ids_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_with_ids_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_with_ids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size368 = 0;
          $self->{success} = [];
          my $_etype371 = 0;
          $xfer += $input->readListBegin(\$_etype371, \$_size368);
          for (my $_i372 = 0; $_i372 < $_size368; ++$_i372)
          {
            my $elem373 = undef;
            $xfer += $input->readString(\$elem373);
            push(@{$self->{success}},$elem373);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter374 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter374);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_get_listing_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_get_listing_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_get_listing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_get_listing_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_get_listing_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_get_listing_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_get_listing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size375 = 0;
          $self->{success} = [];
          my $_etype378 = 0;
          $xfer += $input->readListBegin(\$_etype378, \$_size375);
          for (my $_i379 = 0; $_i379 < $_size375; ++$_i379)
          {
            my $elem380 = undef;
            $elem380 = new Hypertable::ThriftGen::NamespaceListing();
            $xfer += $elem380->read($input);
            push(@{$self->{success}},$elem380);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_get_listing_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter381 (@{$self->{success}}) 
        {
          $xfer += ${iter381}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size382 = 0;
          $self->{success} = [];
          my $_etype385 = 0;
          $xfer += $input->readListBegin(\$_etype385, \$_size382);
          for (my $_i386 = 0; $_i386 < $_size382; ++$_i386)
          {
            my $elem387 = undef;
            $elem387 = new Hypertable::ThriftGen::NamespaceListing();
            $xfer += $elem387->read($input);
            push(@{$self->{success}},$elem387);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter388 (@{$self->{success}}) 
        {
          $xfer += ${iter388}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_splits_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_splits_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_splits_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_splits_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size389 = 0;
          $self->{success} = [];
          my $_etype392 = 0;
          $xfer += $input->readListBegin(\$_etype392, \$_size389);
          for (my $_i393 = 0; $_i393 < $_size389; ++$_i393)
          {
            my $elem394 = undef;
            $elem394 = new Hypertable::ThriftGen::TableSplit();
            $xfer += $elem394->read($input);
            push(@{$self->{success}},$elem394);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter395 (@{$self->{success}}) 
        {
          $xfer += ${iter395}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size396 = 0;
          $self->{success} = [];
          my $_etype399 = 0;
          $xfer += $input->readListBegin(\$_etype399, \$_size396);
          for (my $_i400 = 0; $_i400 < $_size396; ++$_i400)
          {
            my $elem401 = undef;
            $elem401 = new Hypertable::ThriftGen::TableSplit();
            $xfer += $elem401->read($input);
            push(@{$self->{success}},$elem401);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter402 (@{$self->{success}}) 
        {
          $xfer += ${iter402}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_args->mk_accessors( qw( ns name new_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{new_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{new_name}) {
      $self->{new_name} = $vals->{new_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{new_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_name}) {
    $xfer += $output->writeFieldBegin('new_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{new_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_rename_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_rename_args->mk_accessors( qw( ns name new_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{new_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{new_name}) {
      $self->{new_name} = $vals->{new_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_rename_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{new_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_rename_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_name}) {
    $xfer += $output->writeFieldBegin('new_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{new_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_rename_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_rename_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_rename_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_rename_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_args->mk_accessors( qw( ns name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_drop_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_drop_args->mk_accessors( qw( ns name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_drop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_drop_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_drop_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_drop_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_drop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_drop_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_generate_guid_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_args->mk_accessors( qw( ns table_name key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{key} = new Hypertable::ThriftGen::Key();
        $xfer += $self->{key}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRUCT, 3);
    $xfer += $self->{key}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_error_get_text_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_error_get_text_args->mk_accessors( qw( error_code ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{error_code} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{error_code}) {
      $self->{error_code} = $vals->{error_code};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_error_get_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{error_code});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_error_get_text_args');
  if (defined $self->{error_code}) {
    $xfer += $output->writeFieldBegin('error_code', TType::I32, 1);
    $xfer += $output->writeI32($self->{error_code});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_error_get_text_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_error_get_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_error_get_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_error_get_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientServiceIf;

use strict;


sub namespace_create{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub create_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub namespace_open{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub open_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub namespace_close{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub close_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub future_open{
  my $self = shift;
  my $capacity = shift;

  die 'implement interface';
}

sub open_future{
  my $self = shift;
  my $capacity = shift;

  die 'implement interface';
}

sub future_cancel{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub cancel_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_is_empty{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_full{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_close{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub close_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  die 'implement interface';
}

sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  die 'implement interface';
}

sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  die 'implement interface';
}

sub shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub namespace_exists{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  die 'implement interface';
}

sub table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  die 'implement interface';
}

sub table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub namespace_get_listing{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub get_listing{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  die 'implement interface';
}

sub table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub generate_guid{
  my $self = shift;

  die 'implement interface';
}

sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

sub error_get_text{
  my $self = shift;
  my $error_code = shift;

  die 'implement interface';
}

package Hypertable::ThriftGen::ClientServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub namespace_create{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_create($ns);
}

sub create_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->create_namespace($ns);
}

sub create_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->create_table($ns, $table_name, $schema);
}

sub table_create{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->table_create($ns, $table_name, $schema);
}

sub alter_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->alter_table($ns, $table_name, $schema);
}

sub table_alter{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->table_alter($ns, $table_name, $schema);
}

sub namespace_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_open($ns);
}

sub open_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->open_namespace($ns);
}

sub namespace_close{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_close($ns);
}

sub close_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->close_namespace($ns);
}

sub future_open{
  my ($self, $request) = @_;

  my $capacity = ($request->{'capacity'}) ? $request->{'capacity'} : undef;
  return $self->{impl}->future_open($capacity);
}

sub open_future{
  my ($self, $request) = @_;

  my $capacity = ($request->{'capacity'}) ? $request->{'capacity'} : undef;
  return $self->{impl}->open_future($capacity);
}

sub future_cancel{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_cancel($ff);
}

sub cancel_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->cancel_future($ff);
}

sub future_get_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result($ff, $timeout_millis);
}

sub get_future_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result($ff, $timeout_millis);
}

sub future_get_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result_as_arrays($ff, $timeout_millis);
}

sub get_future_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result_as_arrays($ff, $timeout_millis);
}

sub future_get_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result_serialized($ff, $timeout_millis);
}

sub get_future_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result_serialized($ff, $timeout_millis);
}

sub future_is_empty{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_empty($ff);
}

sub future_is_full{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_full($ff);
}

sub future_is_cancelled{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_cancelled($ff);
}

sub future_has_outstanding{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_has_outstanding($ff);
}

sub future_close{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_close($ff);
}

sub close_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->close_future($ff);
}

sub scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->scanner_open($ns, $table_name, $scan_spec);
}

sub open_scanner{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner($ns, $table_name, $scan_spec);
}

sub async_scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->async_scanner_open($ns, $table_name, $future, $scan_spec);
}

sub open_scanner_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner_async($ns, $table_name, $future, $scan_spec);
}

sub scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_close($scanner);
}

sub close_scanner{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner($scanner);
}

sub async_scanner_cancel{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_cancel($scanner);
}

sub cancel_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->cancel_scanner_async($scanner);
}

sub async_scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_close($scanner);
}

sub close_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner_async($scanner);
}

sub scanner_get_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells($scanner);
}

sub next_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells($scanner);
}

sub scanner_get_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_as_arrays($scanner);
}

sub next_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_as_arrays($scanner);
}

sub scanner_get_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_serialized($scanner);
}

sub next_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_serialized($scanner);
}

sub scanner_get_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row($scanner);
}

sub next_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row($scanner);
}

sub scanner_get_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_as_arrays($scanner);
}

sub next_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_as_arrays($scanner);
}

sub scanner_get_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_serialized($scanner);
}

sub next_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_serialized($scanner);
}

sub get_row{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row($ns, $table_name, $row);
}

sub get_row_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_as_arrays($ns, $name, $row);
}

sub get_row_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_serialized($ns, $table_name, $row);
}

sub get_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  return $self->{impl}->get_cell($ns, $table_name, $row, $column);
}

sub get_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells($ns, $table_name, $scan_spec);
}

sub get_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_as_arrays($ns, $name, $scan_spec);
}

sub get_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_serialized($ns, $name, $scan_spec);
}

sub shared_mutator_refresh{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  return $self->{impl}->shared_mutator_refresh($ns, $table_name, $mutate_spec);
}

sub refresh_shared_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  return $self->{impl}->refresh_shared_mutator($ns, $table_name, $mutate_spec);
}

sub shared_mutator_set_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->shared_mutator_set_cells($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells($ns, $table_name, $mutate_spec, $cells);
}

sub shared_mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->shared_mutator_set_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
}

sub shared_mutator_set_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->shared_mutator_set_cell($ns, $table_name, $mutate_spec, $cell);
}

sub offer_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell($ns, $table_name, $mutate_spec, $cell);
}

sub shared_mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->shared_mutator_set_cell_as_array($ns, $table_name, $mutate_spec, $cell);
}

sub offer_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
}

sub mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->mutator_open($ns, $table_name, $flags, $flush_interval);
}

sub open_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->open_mutator($ns, $table_name, $flags, $flush_interval);
}

sub async_mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->async_mutator_open($ns, $table_name, $future, $flags);
}

sub open_mutator_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->open_mutator_async($ns, $table_name, $future, $flags);
}

sub mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_close($mutator);
}

sub close_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator($mutator);
}

sub async_mutator_cancel{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_cancel($mutator);
}

sub cancel_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->cancel_mutator_async($mutator);
}

sub async_mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_close($mutator);
}

sub close_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator_async($mutator);
}

sub mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell($mutator, $cell);
}

sub set_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell($ns, $table_name, $cell);
}

sub mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array($ns, $table_name, $cell);
}

sub mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells($mutator, $cells);
}

sub set_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells($ns, $table_name, $cells);
}

sub mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays($ns, $table_name, $cells);
}

sub mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_serialized($ns, $table_name, $cells);
}

sub mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_flush($mutator);
}

sub flush_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator($mutator);
}

sub async_mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell($mutator, $cell);
}

sub set_cell_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_async($mutator, $cell);
}

sub async_mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array_async($mutator, $cell);
}

sub async_mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells($mutator, $cells);
}

sub set_cells_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_async($mutator, $cells);
}

sub async_mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays_async($mutator, $cells);
}

sub async_mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->async_mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->set_cells_serialized_async($mutator, $cells, $flush);
}

sub async_mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_flush($mutator);
}

sub flush_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator_async($mutator);
}

sub namespace_exists{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_exists($ns);
}

sub exists_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->exists_namespace($ns);
}

sub exists_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->exists_table($ns, $name);
}

sub table_exists{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->table_exists($ns, $name);
}

sub table_get_id{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_id($ns, $table_name);
}

sub get_table_id{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_id($ns, $table_name);
}

sub table_get_schema_str{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema_str($ns, $table_name);
}

sub get_schema_str{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str($ns, $table_name);
}

sub table_get_schema_str_with_ids{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema_str_with_ids($ns, $table_name);
}

sub get_schema_str_with_ids{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str_with_ids($ns, $table_name);
}

sub table_get_schema{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema($ns, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($ns, $table_name);
}

sub get_tables{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_tables($ns);
}

sub namespace_get_listing{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_get_listing($ns);
}

sub get_listing{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_listing($ns);
}

sub table_get_splits{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_splits($ns, $table_name);
}

sub get_table_splits{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_splits($ns, $table_name);
}

sub namespace_drop{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->namespace_drop($ns, $if_exists);
}

sub drop_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_namespace($ns, $if_exists);
}

sub rename_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $new_name = ($request->{'new_name'}) ? $request->{'new_name'} : undef;
  return $self->{impl}->rename_table($ns, $name, $new_name);
}

sub table_rename{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $new_name = ($request->{'new_name'}) ? $request->{'new_name'} : undef;
  return $self->{impl}->table_rename($ns, $name, $new_name);
}

sub drop_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_table($ns, $name, $if_exists);
}

sub table_drop{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->table_drop($ns, $name, $if_exists);
}

sub generate_guid{
  my ($self, $request) = @_;

  return $self->{impl}->generate_guid();
}

sub create_cell_unique{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->create_cell_unique($ns, $table_name, $key, $value);
}

sub error_get_text{
  my ($self, $request) = @_;

  my $error_code = ($request->{'error_code'}) ? $request->{'error_code'} : undef;
  return $self->{impl}->error_get_text($error_code);
}

package Hypertable::ThriftGen::ClientServiceClient;


use base qw(Hypertable::ThriftGen::ClientServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub namespace_create{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_create($ns);
  $self->recv_namespace_create();
}

sub send_namespace_create{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_create', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_create_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_create_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub create_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_create_namespace($ns);
  $self->recv_create_namespace();
}

sub send_create_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('create_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_create_table($ns, $table_name, $schema);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_table_create($ns, $table_name, $schema);
  $self->recv_table_create();
}

sub send_table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('table_create', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_create_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_create_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_alter_table($ns, $table_name, $schema);
  $self->recv_alter_table();
}

sub send_alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('alter_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_alter_table_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_alter_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_table_alter($ns, $table_name, $schema);
  $self->recv_table_alter();
}

sub send_table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('table_alter', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_alter_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_alter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_alter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_open{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_open($ns);
  return $self->recv_namespace_open();
}

sub send_namespace_open{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_open_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_open failed: unknown result";
}
sub open_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_open_namespace($ns);
  return $self->recv_open_namespace();
}

sub send_open_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('open_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_namespace failed: unknown result";
}
sub namespace_close{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_close($ns);
  $self->recv_namespace_close();
}

sub send_namespace_close{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_close_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_close_namespace($ns);
  $self->recv_close_namespace();
}

sub send_close_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('close_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_open{
  my $self = shift;
  my $capacity = shift;

    $self->send_future_open($capacity);
  return $self->recv_future_open();
}

sub send_future_open{
  my $self = shift;
  my $capacity = shift;

  $self->{output}->writeMessageBegin('future_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_open_args();
  $args->{capacity} = $capacity;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_open failed: unknown result";
}
sub open_future{
  my $self = shift;
  my $capacity = shift;

    $self->send_open_future($capacity);
  return $self->recv_open_future();
}

sub send_open_future{
  my $self = shift;
  my $capacity = shift;

  $self->{output}->writeMessageBegin('open_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_future_args();
  $args->{capacity} = $capacity;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_future failed: unknown result";
}
sub future_cancel{
  my $self = shift;
  my $ff = shift;

    $self->send_future_cancel($ff);
  $self->recv_future_cancel();
}

sub send_future_cancel{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_cancel_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_future{
  my $self = shift;
  my $ff = shift;

    $self->send_cancel_future($ff);
  $self->recv_cancel_future();
}

sub send_cancel_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('cancel_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_future_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result($ff, $timeout_millis);
  return $self->recv_future_get_result();
}

sub send_future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result failed: unknown result";
}
sub get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result($ff, $timeout_millis);
  return $self->recv_get_future_result();
}

sub send_get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result failed: unknown result";
}
sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result_as_arrays($ff, $timeout_millis);
  return $self->recv_future_get_result_as_arrays();
}

sub send_future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_as_arrays failed: unknown result";
}
sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result_as_arrays($ff, $timeout_millis);
  return $self->recv_get_future_result_as_arrays();
}

sub send_get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_as_arrays failed: unknown result";
}
sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result_serialized($ff, $timeout_millis);
  return $self->recv_future_get_result_serialized();
}

sub send_future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_serialized failed: unknown result";
}
sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result_serialized($ff, $timeout_millis);
  return $self->recv_get_future_result_serialized();
}

sub send_get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_args();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_serialized failed: unknown result";
}
sub future_is_empty{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_empty($ff);
  return $self->recv_future_is_empty();
}

sub send_future_is_empty{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_empty', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_empty_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_empty{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_empty_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_empty failed: unknown result";
}
sub future_is_full{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_full($ff);
  return $self->recv_future_is_full();
}

sub send_future_is_full{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_full', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_full_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_full{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_full_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_full failed: unknown result";
}
sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_cancelled($ff);
  return $self->recv_future_is_cancelled();
}

sub send_future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_cancelled', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_cancelled_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_cancelled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_cancelled_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_cancelled failed: unknown result";
}
sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

    $self->send_future_has_outstanding($ff);
  return $self->recv_future_has_outstanding();
}

sub send_future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_has_outstanding', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_has_outstanding_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_has_outstanding{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_has_outstanding_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_has_outstanding failed: unknown result";
}
sub future_close{
  my $self = shift;
  my $ff = shift;

    $self->send_future_close($ff);
  $self->recv_future_close();
}

sub send_future_close{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_close_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_future{
  my $self = shift;
  my $ff = shift;

    $self->send_close_future($ff);
  $self->recv_close_future();
}

sub send_close_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('close_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_future_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_scanner_open($ns, $table_name, $scan_spec);
  return $self->recv_scanner_open();
}

sub send_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('scanner_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_open failed: unknown result";
}
sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_open_scanner($ns, $table_name, $scan_spec);
  return $self->recv_open_scanner();
}

sub send_open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner failed: unknown result";
}
sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_async_scanner_open($ns, $table_name, $future, $scan_spec);
  return $self->recv_async_scanner_open();
}

sub send_async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('async_scanner_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_scanner_open failed: unknown result";
}
sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_open_scanner_async($ns, $table_name, $future, $scan_spec);
  return $self->recv_open_scanner_async();
}

sub send_open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_async_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner_async failed: unknown result";
}
sub scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_close($scanner);
  $self->recv_scanner_close();
}

sub send_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_close_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner($scanner);
  $self->recv_close_scanner();
}

sub send_close_scanner{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_cancel($scanner);
  $self->recv_async_scanner_cancel();
}

sub send_async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_cancel_scanner_async($scanner);
  $self->recv_cancel_scanner_async();
}

sub send_cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('cancel_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_close($scanner);
  $self->recv_async_scanner_close();
}

sub send_async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_close_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner_async($scanner);
  $self->recv_close_scanner_async();
}

sub send_close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_async_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells($scanner);
  return $self->recv_scanner_get_cells();
}

sub send_scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells failed: unknown result";
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells($scanner);
  return $self->recv_next_cells();
}

sub send_next_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells failed: unknown result";
}
sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_as_arrays($scanner);
  return $self->recv_scanner_get_cells_as_arrays();
}

sub send_scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells_as_arrays failed: unknown result";
}
sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_as_arrays($scanner);
  return $self->recv_next_cells_as_arrays();
}

sub send_next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_as_arrays failed: unknown result";
}
sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_serialized($scanner);
  return $self->recv_scanner_get_cells_serialized();
}

sub send_scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells_serialized failed: unknown result";
}
sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_serialized($scanner);
  return $self->recv_next_cells_serialized();
}

sub send_next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_serialized failed: unknown result";
}
sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row($scanner);
  return $self->recv_scanner_get_row();
}

sub send_scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row failed: unknown result";
}
sub next_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row($scanner);
  return $self->recv_next_row();
}

sub send_next_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row failed: unknown result";
}
sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_as_arrays($scanner);
  return $self->recv_scanner_get_row_as_arrays();
}

sub send_scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_as_arrays failed: unknown result";
}
sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_as_arrays($scanner);
  return $self->recv_next_row_as_arrays();
}

sub send_next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_as_arrays failed: unknown result";
}
sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_serialized($scanner);
  return $self->recv_scanner_get_row_serialized();
}

sub send_scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_serialized failed: unknown result";
}
sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_serialized($scanner);
  return $self->recv_next_row_serialized();
}

sub send_next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_serialized failed: unknown result";
}
sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row($ns, $table_name, $row);
  return $self->recv_get_row();
}

sub send_get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row failed: unknown result";
}
sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row_as_arrays($ns, $name, $row);
  return $self->recv_get_row_as_arrays();
}

sub send_get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_as_arrays failed: unknown result";
}
sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row_serialized($ns, $table_name, $row);
  return $self->recv_get_row_serialized();
}

sub send_get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_serialized_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_serialized failed: unknown result";
}
sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

    $self->send_get_cell($ns, $table_name, $row, $column);
  return $self->recv_get_cell();
}

sub send_get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  $self->{output}->writeMessageBegin('get_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cell failed: unknown result";
}
sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_get_cells($ns, $table_name, $scan_spec);
  return $self->recv_get_cells();
}

sub send_get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells failed: unknown result";
}
sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_as_arrays($ns, $name, $scan_spec);
  return $self->recv_get_cells_as_arrays();
}

sub send_get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_as_arrays failed: unknown result";
}
sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_serialized($ns, $name, $scan_spec);
  return $self->recv_get_cells_serialized();
}

sub send_get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_serialized_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_serialized failed: unknown result";
}
sub shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

    $self->send_shared_mutator_refresh($ns, $table_name, $mutate_spec);
  $self->recv_shared_mutator_refresh();
}

sub send_shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  $self->{output}->writeMessageBegin('shared_mutator_refresh', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_refresh{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

    $self->send_refresh_shared_mutator($ns, $table_name, $mutate_spec);
  $self->recv_refresh_shared_mutator();
}

sub send_refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  $self->{output}->writeMessageBegin('refresh_shared_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_refresh_shared_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_shared_mutator_set_cells($ns, $table_name, $mutate_spec, $cells);
  $self->recv_shared_mutator_set_cells();
}

sub send_shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells();
}

sub send_offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_shared_mutator_set_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
  $self->recv_shared_mutator_set_cells_as_arrays();
}

sub send_shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells_as_arrays();
}

sub send_offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_shared_mutator_set_cell($ns, $table_name, $mutate_spec, $cell);
  $self->recv_shared_mutator_set_cell();
}

sub send_shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell();
}

sub send_offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_shared_mutator_set_cell_as_array($ns, $table_name, $mutate_spec, $cell);
  $self->recv_shared_mutator_set_cell_as_array();
}

sub send_shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell_as_array();
}

sub send_offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_mutator_open($ns, $table_name, $flags, $flush_interval);
  return $self->recv_mutator_open();
}

sub send_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('mutator_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "mutator_open failed: unknown result";
}
sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_open_mutator($ns, $table_name, $flags, $flush_interval);
  return $self->recv_open_mutator();
}

sub send_open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('open_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator failed: unknown result";
}
sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_async_mutator_open($ns, $table_name, $future, $flags);
  return $self->recv_async_mutator_open();
}

sub send_async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('async_mutator_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_mutator_open failed: unknown result";
}
sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_open_mutator_async($ns, $table_name, $future, $flags);
  return $self->recv_open_mutator_async();
}

sub send_open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('open_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_async_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator_async failed: unknown result";
}
sub mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_close($mutator);
  $self->recv_mutator_close();
}

sub send_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_close_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator($mutator);
  $self->recv_close_mutator();
}

sub send_close_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_cancel($mutator);
  $self->recv_async_mutator_cancel();
}

sub send_async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_cancel_mutator_async($mutator);
  $self->recv_cancel_mutator_async();
}

sub send_cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('cancel_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_close($mutator);
  $self->recv_async_mutator_close();
}

sub send_async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_close_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator_async($mutator);
  $self->recv_close_mutator_async();
}

sub send_close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell($mutator, $cell);
  $self->recv_mutator_set_cell();
}

sub send_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell($ns, $table_name, $cell);
  $self->recv_set_cell();
}

sub send_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_mutator_set_cell_as_array();
}

sub send_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell_as_array($ns, $table_name, $cell);
  $self->recv_set_cell_as_array();
}

sub send_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells($mutator, $cells);
  $self->recv_mutator_set_cells();
}

sub send_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells($ns, $table_name, $cells);
  $self->recv_set_cells();
}

sub send_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_mutator_set_cells_as_arrays();
}

sub send_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays($ns, $table_name, $cells);
  $self->recv_set_cells_as_arrays();
}

sub send_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_mutator_set_cells_serialized();
}

sub send_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells_serialized($ns, $table_name, $cells);
  $self->recv_set_cells_serialized();
}

sub send_set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_flush($mutator);
  $self->recv_mutator_flush();
}

sub send_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_flush', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_flush_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_flush_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator($mutator);
  $self->recv_flush_mutator();
}

sub send_flush_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell($mutator, $cell);
  $self->recv_async_mutator_set_cell();
}

sub send_async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_async($mutator, $cell);
  $self->recv_set_cell_async();
}

sub send_set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_async_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_async_mutator_set_cell_as_array();
}

sub send_async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_as_array_async($mutator, $cell);
  $self->recv_set_cell_as_array_async();
}

sub send_set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells($mutator, $cells);
  $self->recv_async_mutator_set_cells();
}

sub send_async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_async($mutator, $cells);
  $self->recv_set_cells_async();
}

sub send_set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_async_mutator_set_cells_as_arrays();
}

sub send_async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays_async($mutator, $cells);
  $self->recv_set_cells_as_arrays_async();
}

sub send_set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_async_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_async_mutator_set_cells_serialized();
}

sub send_async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_set_cells_serialized_async($mutator, $cells, $flush);
  $self->recv_set_cells_serialized_async();
}

sub send_set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_flush($mutator);
  $self->recv_async_mutator_flush();
}

sub send_async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_flush', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_flush_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_flush_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator_async($mutator);
  $self->recv_flush_mutator_async();
}

sub send_flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_exists{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_exists($ns);
  return $self->recv_namespace_exists();
}

sub send_namespace_exists{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_exists', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_exists_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_exists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_exists failed: unknown result";
}
sub exists_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_exists_namespace($ns);
  return $self->recv_exists_namespace();
}

sub send_exists_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('exists_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_exists_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_exists_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_namespace failed: unknown result";
}
sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

    $self->send_exists_table($ns, $name);
  return $self->recv_exists_table();
}

sub send_exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('exists_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_exists_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_exists_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_table failed: unknown result";
}
sub table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

    $self->send_table_exists($ns, $name);
  return $self->recv_table_exists();
}

sub send_table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('table_exists', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_exists_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_exists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_exists failed: unknown result";
}
sub table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_id($ns, $table_name);
  return $self->recv_table_get_id();
}

sub send_table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_id', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_get_id_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_get_id_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_id failed: unknown result";
}
sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_id($ns, $table_name);
  return $self->recv_get_table_id();
}

sub send_get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_id', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_id failed: unknown result";
}
sub table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema_str($ns, $table_name);
  return $self->recv_table_get_schema_str();
}

sub send_table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema_str', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_str_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema_str{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_str_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema_str failed: unknown result";
}
sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str($ns, $table_name);
  return $self->recv_get_schema_str();
}

sub send_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str failed: unknown result";
}
sub table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema_str_with_ids($ns, $table_name);
  return $self->recv_table_get_schema_str_with_ids();
}

sub send_table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema_str_with_ids', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema_str_with_ids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema_str_with_ids failed: unknown result";
}
sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str_with_ids($ns, $table_name);
  return $self->recv_get_schema_str_with_ids();
}

sub send_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str_with_ids', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str_with_ids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str_with_ids failed: unknown result";
}
sub table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema($ns, $table_name);
  return $self->recv_table_get_schema();
}

sub send_table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema($ns, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema failed: unknown result";
}
sub get_tables{
  my $self = shift;
  my $ns = shift;

    $self->send_get_tables($ns);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_tables failed: unknown result";
}
sub namespace_get_listing{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_get_listing($ns);
  return $self->recv_namespace_get_listing();
}

sub send_namespace_get_listing{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_get_listing', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_get_listing_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_get_listing{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_get_listing_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_get_listing failed: unknown result";
}
sub get_listing{
  my $self = shift;
  my $ns = shift;

    $self->send_get_listing($ns);
  return $self->recv_get_listing();
}

sub send_get_listing{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_listing', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_listing_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_listing{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_listing_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_listing failed: unknown result";
}
sub table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_splits($ns, $table_name);
  return $self->recv_table_get_splits();
}

sub send_table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_get_splits_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_get_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_splits failed: unknown result";
}
sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_splits($ns, $table_name);
  return $self->recv_get_table_splits();
}

sub send_get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_splits_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_splits failed: unknown result";
}
sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_namespace_drop($ns, $if_exists);
  $self->recv_namespace_drop();
}

sub send_namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('namespace_drop', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_drop_args();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_drop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_drop_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_drop_namespace($ns, $if_exists);
  $self->recv_drop_namespace();
}

sub send_drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_namespace_args();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

    $self->send_rename_table($ns, $name, $new_name);
  $self->recv_rename_table();
}

sub send_rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  $self->{output}->writeMessageBegin('rename_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_rename_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{new_name} = $new_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rename_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_rename_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

    $self->send_table_rename($ns, $name, $new_name);
  $self->recv_table_rename();
}

sub send_table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  $self->{output}->writeMessageBegin('table_rename', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_rename_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{new_name} = $new_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_rename{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_rename_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_drop_table($ns, $name, $if_exists);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_table_drop($ns, $name, $if_exists);
  $self->recv_table_drop();
}

sub send_table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('table_drop', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_table_drop_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_drop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_table_drop_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub generate_guid{
  my $self = shift;

    $self->send_generate_guid();
  return $self->recv_generate_guid();
}

sub send_generate_guid{
  my $self = shift;

  $self->{output}->writeMessageBegin('generate_guid', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_generate_guid_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_generate_guid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_generate_guid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "generate_guid failed: unknown result";
}
sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

    $self->send_create_cell_unique($ns, $table_name, $key, $value);
  return $self->recv_create_cell_unique();
}

sub send_create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('create_cell_unique', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_cell_unique_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{key} = $key;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_cell_unique{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_cell_unique_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "create_cell_unique failed: unknown result";
}
sub error_get_text{
  my $self = shift;
  my $error_code = shift;

    $self->send_error_get_text($error_code);
  return $self->recv_error_get_text();
}

sub send_error_get_text{
  my $self = shift;
  my $error_code = shift;

  $self->{output}->writeMessageBegin('error_get_text', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_error_get_text_args();
  $args->{error_code} = $error_code;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_error_get_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_error_get_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "error_get_text failed: unknown result";
}
package Hypertable::ThriftGen::ClientServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_namespace_create {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_create_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_create_result();
    eval {
      $self->{handler}->namespace_create($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_create', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_namespace_result();
    eval {
      $self->{handler}->create_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
    eval {
      $self->{handler}->create_table($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_create {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_create_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_create_result();
    eval {
      $self->{handler}->table_create($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_create', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_alter_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_alter_table_result();
    eval {
      $self->{handler}->alter_table($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('alter_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_alter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_alter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_alter_result();
    eval {
      $self->{handler}->table_alter($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_alter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_open_result();
    eval {
      $result->{success} = $self->{handler}->namespace_open($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_namespace_result();
    eval {
      $result->{success} = $self->{handler}->open_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_close_result();
    eval {
      $self->{handler}->namespace_close($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_namespace_result();
    eval {
      $self->{handler}->close_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_open_result();
    eval {
      $result->{success} = $self->{handler}->future_open($args->capacity);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_future_result();
    eval {
      $result->{success} = $self->{handler}->open_future($args->capacity);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_cancel_result();
    eval {
      $self->{handler}->future_cancel($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_future_result();
    eval {
      $self->{handler}->cancel_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result_as_arrays($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result_as_arrays($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result_serialized($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result_serialized($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_empty {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_empty_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_empty_result();
    eval {
      $result->{success} = $self->{handler}->future_is_empty($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_empty', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_full {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_full_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_full_result();
    eval {
      $result->{success} = $self->{handler}->future_is_full($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_full', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_cancelled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_cancelled_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_cancelled_result();
    eval {
      $result->{success} = $self->{handler}->future_is_cancelled($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_cancelled', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_has_outstanding {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_has_outstanding_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_has_outstanding_result();
    eval {
      $result->{success} = $self->{handler}->future_has_outstanding($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_has_outstanding', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_close_result();
    eval {
      $self->{handler}->future_close($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_future_result();
    eval {
      $self->{handler}->close_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_open_result();
    eval {
      $result->{success} = $self->{handler}->scanner_open($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
    eval {
      $result->{success} = $self->{handler}->open_scanner($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_open_result();
    eval {
      $result->{success} = $self->{handler}->async_scanner_open($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_scanner_async_result();
    eval {
      $result->{success} = $self->{handler}->open_scanner_async($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_close_result();
    eval {
      $self->{handler}->scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
    eval {
      $self->{handler}->close_scanner($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_result();
    eval {
      $self->{handler}->async_scanner_cancel($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_result();
    eval {
      $self->{handler}->cancel_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_close_result();
    eval {
      $self->{handler}->async_scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_scanner_async_result();
    eval {
      $self->{handler}->close_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
    eval {
      $result->{success} = $self->{handler}->next_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_serialized_result();
    eval {
      $result->{success} = $self->{handler}->next_cells_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
    eval {
      $result->{success} = $self->{handler}->next_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->next_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
    eval {
      $result->{success} = $self->{handler}->get_row($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_row_as_arrays($args->ns, $args->name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_row_serialized($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
    eval {
      $result->{success} = $self->{handler}->get_cell($args->ns, $args->table_name, $args->row, $args->column);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
    eval {
      $result->{success} = $self->{handler}->get_cells($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_cells_as_arrays($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_cells_serialized($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_refresh {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result();
    eval {
      $self->{handler}->shared_mutator_refresh($args->ns, $args->table_name, $args->mutate_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('shared_mutator_refresh', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refresh_shared_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result();
    eval {
      $self->{handler}->refresh_shared_mutator($args->ns, $args->table_name, $args->mutate_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('refresh_shared_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result();
    eval {
      $self->{handler}->shared_mutator_set_cells($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('shared_mutator_set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cells_result();
    eval {
      $self->{handler}->offer_cells($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result();
    eval {
      $self->{handler}->shared_mutator_set_cells_as_arrays($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('shared_mutator_set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result();
    eval {
      $self->{handler}->offer_cells_as_arrays($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result();
    eval {
      $self->{handler}->shared_mutator_set_cell($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('shared_mutator_set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cell_result();
    eval {
      $self->{handler}->offer_cell($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result();
    eval {
      $self->{handler}->shared_mutator_set_cell_as_array($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('shared_mutator_set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_result();
    eval {
      $self->{handler}->offer_cell_as_array($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_open_result();
    eval {
      $result->{success} = $self->{handler}->mutator_open($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
    eval {
      $result->{success} = $self->{handler}->open_mutator($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_open_result();
    eval {
      $result->{success} = $self->{handler}->async_mutator_open($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_mutator_async_result();
    eval {
      $result->{success} = $self->{handler}->open_mutator_async($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_close_result();
    eval {
      $self->{handler}->mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
    eval {
      $self->{handler}->close_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_result();
    eval {
      $self->{handler}->async_mutator_cancel($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_result();
    eval {
      $self->{handler}->cancel_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_close_result();
    eval {
      $self->{handler}->async_mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_mutator_async_result();
    eval {
      $self->{handler}->close_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_result();
    eval {
      $self->{handler}->mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
    eval {
      $self->{handler}->set_cell($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result();
    eval {
      $self->{handler}->mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
    eval {
      $self->{handler}->set_cell_as_array($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_result();
    eval {
      $self->{handler}->mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
    eval {
      $self->{handler}->set_cells($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result();
    eval {
      $self->{handler}->mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
    eval {
      $self->{handler}->set_cells_as_arrays($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result();
    eval {
      $self->{handler}->mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_result();
    eval {
      $self->{handler}->set_cells_serialized($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_flush_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_flush_result();
    eval {
      $self->{handler}->mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_flush', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
    eval {
      $self->{handler}->flush_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('flush_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result();
    eval {
      $self->{handler}->async_mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_async_result();
    eval {
      $self->{handler}->set_cell_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result();
    eval {
      $self->{handler}->async_mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result();
    eval {
      $self->{handler}->set_cell_as_array_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_as_array_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result();
    eval {
      $self->{handler}->async_mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_async_result();
    eval {
      $self->{handler}->set_cells_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result();
    eval {
      $self->{handler}->async_mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result();
    eval {
      $self->{handler}->set_cells_as_arrays_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_as_arrays_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result();
    eval {
      $self->{handler}->async_mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result();
    eval {
      $self->{handler}->set_cells_serialized_async($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_serialized_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_flush_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_flush_result();
    eval {
      $self->{handler}->async_mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_flush', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_async_result();
    eval {
      $self->{handler}->flush_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('flush_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_exists_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_exists_result();
    eval {
      $result->{success} = $self->{handler}->namespace_exists($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_exists', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_exists_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_exists_namespace_result();
    eval {
      $result->{success} = $self->{handler}->exists_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('exists_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_exists_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_exists_table_result();
    eval {
      $result->{success} = $self->{handler}->exists_table($args->ns, $args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('exists_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_exists_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_exists_result();
    eval {
      $result->{success} = $self->{handler}->table_exists($args->ns, $args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_exists', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_get_id_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_get_id_result();
    eval {
      $result->{success} = $self->{handler}->table_get_id($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_get_id', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
    eval {
      $result->{success} = $self->{handler}->get_table_id($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_table_id', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema_str {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_str_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_str_result();
    eval {
      $result->{success} = $self->{handler}->table_get_schema_str($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_get_schema_str', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_result();
    eval {
      $result->{success} = $self->{handler}->get_schema_str($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema_str', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema_str_with_ids {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result();
    eval {
      $result->{success} = $self->{handler}->table_get_schema_str_with_ids($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_get_schema_str_with_ids', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str_with_ids {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result();
    eval {
      $result->{success} = $self->{handler}->get_schema_str_with_ids($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema_str_with_ids', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->table_get_schema($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_get_listing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_get_listing_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_get_listing_result();
    eval {
      $result->{success} = $self->{handler}->namespace_get_listing($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_get_listing', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_listing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_listing_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_listing_result();
    eval {
      $result->{success} = $self->{handler}->get_listing($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_listing', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_get_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_get_splits_result();
    eval {
      $result->{success} = $self->{handler}->table_get_splits($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_get_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_table_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_table_splits_result();
    eval {
      $result->{success} = $self->{handler}->get_table_splits($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_table_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_drop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_drop_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_drop_result();
    eval {
      $self->{handler}->namespace_drop($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_drop', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_drop_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_drop_namespace_result();
    eval {
      $self->{handler}->drop_namespace($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('drop_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_rename_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_rename_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_rename_table_result();
    eval {
      $self->{handler}->rename_table($args->ns, $args->name, $args->new_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('rename_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_rename {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_rename_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_rename_result();
    eval {
      $self->{handler}->table_rename($args->ns, $args->name, $args->new_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_rename', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->ns, $args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_drop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_table_drop_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_table_drop_result();
    eval {
      $self->{handler}->table_drop($args->ns, $args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('table_drop', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_generate_guid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_generate_guid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_generate_guid_result();
    $result->{success} = $self->{handler}->generate_guid();
    $output->writeMessageBegin('generate_guid', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_cell_unique {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_cell_unique_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_cell_unique_result();
    eval {
      $result->{success} = $self->{handler}->create_cell_unique($args->ns, $args->table_name, $args->key, $args->value);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_cell_unique', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_error_get_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_error_get_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_error_get_text_result();
    $result->{success} = $self->{handler}->error_get_text($args->error_code);
    $output->writeMessageBegin('error_get_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
