#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Hypertable::ThriftGen::ColumnPredicateOperation;
use constant EXACT_MATCH => 1;
use constant PREFIX_MATCH => 2;
use constant REGEX_MATCH => 4;
use constant VALUE_MATCH => 7;
use constant QUALIFIER_EXACT_MATCH => 256;
use constant QUALIFIER_PREFIX_MATCH => 512;
use constant QUALIFIER_REGEX_MATCH => 1024;
use constant QUALIFIER_MATCH => 1792;
package Hypertable::ThriftGen::KeyFlag;
use constant DELETE_ROW => 0;
use constant DELETE_CF => 1;
use constant DELETE_CELL => 2;
use constant DELETE_CELL_VERSION => 3;
use constant INSERT => 255;
package Hypertable::ThriftGen::MutatorFlag;
use constant NO_LOG_SYNC => 1;
use constant IGNORE_UNKNOWN_CFS => 2;
package Hypertable::ThriftGen::RowInterval;
use base qw(Class::Accessor);
Hypertable::ThriftGen::RowInterval->mk_accessors( qw( start_row start_inclusive end_row end_inclusive ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_row} = undef;
  $self->{start_inclusive} = 1;
  $self->{end_row} = undef;
  $self->{end_inclusive} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_row}) {
      $self->{start_row} = $vals->{start_row};
    }
    if (defined $vals->{start_inclusive}) {
      $self->{start_inclusive} = $vals->{start_inclusive};
    }
    if (defined $vals->{end_row}) {
      $self->{end_row} = $vals->{end_row};
    }
    if (defined $vals->{end_inclusive}) {
      $self->{end_inclusive} = $vals->{end_inclusive};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowInterval';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{start_inclusive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{end_inclusive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowInterval');
  if (defined $self->{start_row}) {
    $xfer += $output->writeFieldBegin('start_row', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_inclusive}) {
    $xfer += $output->writeFieldBegin('start_inclusive', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{start_inclusive});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_row}) {
    $xfer += $output->writeFieldBegin('end_row', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_inclusive}) {
    $xfer += $output->writeFieldBegin('end_inclusive', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{end_inclusive});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::CellInterval;
use base qw(Class::Accessor);
Hypertable::ThriftGen::CellInterval->mk_accessors( qw( start_row start_column start_inclusive end_row end_column end_inclusive ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_row} = undef;
  $self->{start_column} = undef;
  $self->{start_inclusive} = 1;
  $self->{end_row} = undef;
  $self->{end_column} = undef;
  $self->{end_inclusive} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_row}) {
      $self->{start_row} = $vals->{start_row};
    }
    if (defined $vals->{start_column}) {
      $self->{start_column} = $vals->{start_column};
    }
    if (defined $vals->{start_inclusive}) {
      $self->{start_inclusive} = $vals->{start_inclusive};
    }
    if (defined $vals->{end_row}) {
      $self->{end_row} = $vals->{end_row};
    }
    if (defined $vals->{end_column}) {
      $self->{end_column} = $vals->{end_column};
    }
    if (defined $vals->{end_inclusive}) {
      $self->{end_inclusive} = $vals->{end_inclusive};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CellInterval';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{start_inclusive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{end_inclusive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CellInterval');
  if (defined $self->{start_row}) {
    $xfer += $output->writeFieldBegin('start_row', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_column}) {
    $xfer += $output->writeFieldBegin('start_column', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_inclusive}) {
    $xfer += $output->writeFieldBegin('start_inclusive', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{start_inclusive});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_row}) {
    $xfer += $output->writeFieldBegin('end_row', TType::STRING, 4);
    $xfer += $output->writeString($self->{end_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_column}) {
    $xfer += $output->writeFieldBegin('end_column', TType::STRING, 5);
    $xfer += $output->writeString($self->{end_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_inclusive}) {
    $xfer += $output->writeFieldBegin('end_inclusive', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{end_inclusive});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ColumnPredicate;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ColumnPredicate->mk_accessors( qw( column_family operation value column_qualifier ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{operation} = undef;
  $self->{value} = undef;
  $self->{column_qualifier} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{operation}) {
      $self->{operation} = $vals->{operation};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{column_qualifier}) {
      $self->{column_qualifier} = $vals->{column_qualifier};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{operation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPredicate');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operation}) {
    $xfer += $output->writeFieldBegin('operation', TType::I32, 2);
    $xfer += $output->writeI32($self->{operation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_qualifier}) {
    $xfer += $output->writeFieldBegin('column_qualifier', TType::STRING, 4);
    $xfer += $output->writeString($self->{column_qualifier});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ScanSpec;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ScanSpec->mk_accessors( qw( row_intervals cell_intervals return_deletes versions row_limit start_time end_time columns keys_only cell_limit cell_limit_per_family row_regexp value_regexp scan_and_filter_rows row_offset cell_offset column_predicates do_not_cache ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row_intervals} = undef;
  $self->{cell_intervals} = undef;
  $self->{return_deletes} = 0;
  $self->{versions} = 0;
  $self->{row_limit} = 0;
  $self->{start_time} = undef;
  $self->{end_time} = undef;
  $self->{columns} = undef;
  $self->{keys_only} = 0;
  $self->{cell_limit} = 0;
  $self->{cell_limit_per_family} = 0;
  $self->{row_regexp} = undef;
  $self->{value_regexp} = undef;
  $self->{scan_and_filter_rows} = 0;
  $self->{row_offset} = 0;
  $self->{cell_offset} = 0;
  $self->{column_predicates} = undef;
  $self->{do_not_cache} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row_intervals}) {
      $self->{row_intervals} = $vals->{row_intervals};
    }
    if (defined $vals->{cell_intervals}) {
      $self->{cell_intervals} = $vals->{cell_intervals};
    }
    if (defined $vals->{return_deletes}) {
      $self->{return_deletes} = $vals->{return_deletes};
    }
    if (defined $vals->{versions}) {
      $self->{versions} = $vals->{versions};
    }
    if (defined $vals->{row_limit}) {
      $self->{row_limit} = $vals->{row_limit};
    }
    if (defined $vals->{start_time}) {
      $self->{start_time} = $vals->{start_time};
    }
    if (defined $vals->{end_time}) {
      $self->{end_time} = $vals->{end_time};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{keys_only}) {
      $self->{keys_only} = $vals->{keys_only};
    }
    if (defined $vals->{cell_limit}) {
      $self->{cell_limit} = $vals->{cell_limit};
    }
    if (defined $vals->{cell_limit_per_family}) {
      $self->{cell_limit_per_family} = $vals->{cell_limit_per_family};
    }
    if (defined $vals->{row_regexp}) {
      $self->{row_regexp} = $vals->{row_regexp};
    }
    if (defined $vals->{value_regexp}) {
      $self->{value_regexp} = $vals->{value_regexp};
    }
    if (defined $vals->{scan_and_filter_rows}) {
      $self->{scan_and_filter_rows} = $vals->{scan_and_filter_rows};
    }
    if (defined $vals->{row_offset}) {
      $self->{row_offset} = $vals->{row_offset};
    }
    if (defined $vals->{cell_offset}) {
      $self->{cell_offset} = $vals->{cell_offset};
    }
    if (defined $vals->{column_predicates}) {
      $self->{column_predicates} = $vals->{column_predicates};
    }
    if (defined $vals->{do_not_cache}) {
      $self->{do_not_cache} = $vals->{do_not_cache};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ScanSpec';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{row_intervals} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Hypertable::ThriftGen::RowInterval();
            $xfer += $elem5->read($input);
            push(@{$self->{row_intervals}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size6 = 0;
          $self->{cell_intervals} = [];
          my $_etype9 = 0;
          $xfer += $input->readListBegin(\$_etype9, \$_size6);
          for (my $_i10 = 0; $_i10 < $_size6; ++$_i10)
          {
            my $elem11 = undef;
            $elem11 = new Hypertable::ThriftGen::CellInterval();
            $xfer += $elem11->read($input);
            push(@{$self->{cell_intervals}},$elem11);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{return_deletes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{versions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_limit});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{end_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size12 = 0;
          $self->{columns} = [];
          my $_etype15 = 0;
          $xfer += $input->readListBegin(\$_etype15, \$_size12);
          for (my $_i16 = 0; $_i16 < $_size12; ++$_i16)
          {
            my $elem17 = undef;
            $xfer += $input->readString(\$elem17);
            push(@{$self->{columns}},$elem17);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{keys_only});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{cell_limit});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{cell_limit_per_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row_regexp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value_regexp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{scan_and_filter_rows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{cell_offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size18 = 0;
          $self->{column_predicates} = [];
          my $_etype21 = 0;
          $xfer += $input->readListBegin(\$_etype21, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $elem23 = undef;
            $elem23 = new Hypertable::ThriftGen::ColumnPredicate();
            $xfer += $elem23->read($input);
            push(@{$self->{column_predicates}},$elem23);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{do_not_cache});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ScanSpec');
  if (defined $self->{row_intervals}) {
    $xfer += $output->writeFieldBegin('row_intervals', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{row_intervals}}));
      {
        foreach my $iter24 (@{$self->{row_intervals}}) 
        {
          $xfer += ${iter24}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell_intervals}) {
    $xfer += $output->writeFieldBegin('cell_intervals', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cell_intervals}}));
      {
        foreach my $iter25 (@{$self->{cell_intervals}}) 
        {
          $xfer += ${iter25}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{return_deletes}) {
    $xfer += $output->writeFieldBegin('return_deletes', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{return_deletes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{versions}) {
    $xfer += $output->writeFieldBegin('versions', TType::I32, 4);
    $xfer += $output->writeI32($self->{versions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_limit}) {
    $xfer += $output->writeFieldBegin('row_limit', TType::I32, 5);
    $xfer += $output->writeI32($self->{row_limit});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_time}) {
    $xfer += $output->writeFieldBegin('start_time', TType::I64, 6);
    $xfer += $output->writeI64($self->{start_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_time}) {
    $xfer += $output->writeFieldBegin('end_time', TType::I64, 7);
    $xfer += $output->writeI64($self->{end_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter26 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter26);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_only}) {
    $xfer += $output->writeFieldBegin('keys_only', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{keys_only});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell_limit_per_family}) {
    $xfer += $output->writeFieldBegin('cell_limit_per_family', TType::I32, 10);
    $xfer += $output->writeI32($self->{cell_limit_per_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_regexp}) {
    $xfer += $output->writeFieldBegin('row_regexp', TType::STRING, 11);
    $xfer += $output->writeString($self->{row_regexp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value_regexp}) {
    $xfer += $output->writeFieldBegin('value_regexp', TType::STRING, 12);
    $xfer += $output->writeString($self->{value_regexp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_and_filter_rows}) {
    $xfer += $output->writeFieldBegin('scan_and_filter_rows', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{scan_and_filter_rows});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell_limit}) {
    $xfer += $output->writeFieldBegin('cell_limit', TType::I32, 14);
    $xfer += $output->writeI32($self->{cell_limit});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_offset}) {
    $xfer += $output->writeFieldBegin('row_offset', TType::I32, 15);
    $xfer += $output->writeI32($self->{row_offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell_offset}) {
    $xfer += $output->writeFieldBegin('cell_offset', TType::I32, 16);
    $xfer += $output->writeI32($self->{cell_offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_predicates}) {
    $xfer += $output->writeFieldBegin('column_predicates', TType::LIST, 17);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{column_predicates}}));
      {
        foreach my $iter27 (@{$self->{column_predicates}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{do_not_cache}) {
    $xfer += $output->writeFieldBegin('do_not_cache', TType::BOOL, 18);
    $xfer += $output->writeBool($self->{do_not_cache});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::Key;
use base qw(Class::Accessor);
Hypertable::ThriftGen::Key->mk_accessors( qw( row column_family column_qualifier timestamp revision flag ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{column_family} = undef;
  $self->{column_qualifier} = undef;
  $self->{timestamp} = undef;
  $self->{revision} = undef;
  $self->{flag} = 255;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{column_qualifier}) {
      $self->{column_qualifier} = $vals->{column_qualifier};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{revision}) {
      $self->{revision} = $vals->{revision};
    }
    if (defined $vals->{flag}) {
      $self->{flag} = $vals->{flag};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Key';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{revision});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Key');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 2);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_qualifier}) {
    $xfer += $output->writeFieldBegin('column_qualifier', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{revision}) {
    $xfer += $output->writeFieldBegin('revision', TType::I64, 5);
    $xfer += $output->writeI64($self->{revision});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flag}) {
    $xfer += $output->writeFieldBegin('flag', TType::I32, 6);
    $xfer += $output->writeI32($self->{flag});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::MutateSpec;
use base qw(Class::Accessor);
Hypertable::ThriftGen::MutateSpec->mk_accessors( qw( appname flush_interval flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{appname} = "";
  $self->{flush_interval} = 1000;
  $self->{flags} = 2;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{appname}) {
      $self->{appname} = $vals->{appname};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'MutateSpec';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{appname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('MutateSpec');
  if (defined $self->{appname}) {
    $xfer += $output->writeFieldBegin('appname', TType::STRING, 1);
    $xfer += $output->writeString($self->{appname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 2);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::Cell;
use base qw(Class::Accessor);
Hypertable::ThriftGen::Cell->mk_accessors( qw( key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cell';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{key} = new Hypertable::ThriftGen::Key();
        $xfer += $self->{key}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cell');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRUCT, 1);
    $xfer += $self->{key}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::Result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::Result->mk_accessors( qw( is_empty id is_scan is_error error error_msg cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{is_empty} = undef;
  $self->{id} = undef;
  $self->{is_scan} = undef;
  $self->{is_error} = undef;
  $self->{error} = undef;
  $self->{error_msg} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{is_empty}) {
      $self->{is_empty} = $vals->{is_empty};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{is_scan}) {
      $self->{is_scan} = $vals->{is_scan};
    }
    if (defined $vals->{is_error}) {
      $self->{is_error} = $vals->{is_error};
    }
    if (defined $vals->{error}) {
      $self->{error} = $vals->{error};
    }
    if (defined $vals->{error_msg}) {
      $self->{error_msg} = $vals->{error_msg};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_empty});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_scan});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{error_msg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{cells} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem33->read($input);
            push(@{$self->{cells}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Result');
  if (defined $self->{is_empty}) {
    $xfer += $output->writeFieldBegin('is_empty', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{is_empty});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I64, 2);
    $xfer += $output->writeI64($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_scan}) {
    $xfer += $output->writeFieldBegin('is_scan', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{is_scan});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_error}) {
    $xfer += $output->writeFieldBegin('is_error', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{is_error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error}) {
    $xfer += $output->writeFieldBegin('error', TType::I32, 5);
    $xfer += $output->writeI32($self->{error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error_msg}) {
    $xfer += $output->writeFieldBegin('error_msg', TType::STRING, 6);
    $xfer += $output->writeString($self->{error_msg});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter34 (@{$self->{cells}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ResultAsArrays;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ResultAsArrays->mk_accessors( qw( is_empty id is_scan is_error error error_msg cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{is_empty} = undef;
  $self->{id} = undef;
  $self->{is_scan} = undef;
  $self->{is_error} = undef;
  $self->{error} = undef;
  $self->{error_msg} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{is_empty}) {
      $self->{is_empty} = $vals->{is_empty};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{is_scan}) {
      $self->{is_scan} = $vals->{is_scan};
    }
    if (defined $vals->{is_error}) {
      $self->{is_error} = $vals->{is_error};
    }
    if (defined $vals->{error}) {
      $self->{error} = $vals->{error};
    }
    if (defined $vals->{error_msg}) {
      $self->{error_msg} = $vals->{error_msg};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ResultAsArrays';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_empty});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_scan});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{error_msg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{cells} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            {
              my $_size41 = 0;
              $elem40 = [];
              my $_etype44 = 0;
              $xfer += $input->readListBegin(\$_etype44, \$_size41);
              for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
              {
                my $elem46 = undef;
                $xfer += $input->readString(\$elem46);
                push(@{$elem40},$elem46);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ResultAsArrays');
  if (defined $self->{is_empty}) {
    $xfer += $output->writeFieldBegin('is_empty', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{is_empty});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I64, 2);
    $xfer += $output->writeI64($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_scan}) {
    $xfer += $output->writeFieldBegin('is_scan', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{is_scan});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_error}) {
    $xfer += $output->writeFieldBegin('is_error', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{is_error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error}) {
    $xfer += $output->writeFieldBegin('error', TType::I32, 5);
    $xfer += $output->writeI32($self->{error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error_msg}) {
    $xfer += $output->writeFieldBegin('error_msg', TType::STRING, 6);
    $xfer += $output->writeString($self->{error_msg});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter47 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter47}}));
            {
              foreach my $iter48 (@{${iter47}}) 
              {
                $xfer += $output->writeString($iter48);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ResultSerialized;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ResultSerialized->mk_accessors( qw( is_empty id is_scan is_error error error_msg cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{is_empty} = undef;
  $self->{id} = undef;
  $self->{is_scan} = undef;
  $self->{is_error} = undef;
  $self->{error} = undef;
  $self->{error_msg} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{is_empty}) {
      $self->{is_empty} = $vals->{is_empty};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{is_scan}) {
      $self->{is_scan} = $vals->{is_scan};
    }
    if (defined $vals->{is_error}) {
      $self->{is_error} = $vals->{is_error};
    }
    if (defined $vals->{error}) {
      $self->{error} = $vals->{error};
    }
    if (defined $vals->{error_msg}) {
      $self->{error_msg} = $vals->{error_msg};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ResultSerialized';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_empty});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_scan});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{error});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{error_msg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ResultSerialized');
  if (defined $self->{is_empty}) {
    $xfer += $output->writeFieldBegin('is_empty', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{is_empty});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I64, 2);
    $xfer += $output->writeI64($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_scan}) {
    $xfer += $output->writeFieldBegin('is_scan', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{is_scan});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_error}) {
    $xfer += $output->writeFieldBegin('is_error', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{is_error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error}) {
    $xfer += $output->writeFieldBegin('error', TType::I32, 5);
    $xfer += $output->writeI32($self->{error});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error_msg}) {
    $xfer += $output->writeFieldBegin('error_msg', TType::STRING, 6);
    $xfer += $output->writeString($self->{error_msg});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 7);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::NamespaceListing;
use base qw(Class::Accessor);
Hypertable::ThriftGen::NamespaceListing->mk_accessors( qw( name is_namespace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{is_namespace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{is_namespace}) {
      $self->{is_namespace} = $vals->{is_namespace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NamespaceListing';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_namespace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NamespaceListing');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_namespace}) {
    $xfer += $output->writeFieldBegin('is_namespace', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{is_namespace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::TableSplit;
use base qw(Class::Accessor);
Hypertable::ThriftGen::TableSplit->mk_accessors( qw( start_row end_row location ip_address hostname ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_row} = undef;
  $self->{end_row} = undef;
  $self->{location} = undef;
  $self->{ip_address} = undef;
  $self->{hostname} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_row}) {
      $self->{start_row} = $vals->{start_row};
    }
    if (defined $vals->{end_row}) {
      $self->{end_row} = $vals->{end_row};
    }
    if (defined $vals->{location}) {
      $self->{location} = $vals->{location};
    }
    if (defined $vals->{ip_address}) {
      $self->{ip_address} = $vals->{ip_address};
    }
    if (defined $vals->{hostname}) {
      $self->{hostname} = $vals->{hostname};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableSplit';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{location});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ip_address});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{hostname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableSplit');
  if (defined $self->{start_row}) {
    $xfer += $output->writeFieldBegin('start_row', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_row}) {
    $xfer += $output->writeFieldBegin('end_row', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{location}) {
    $xfer += $output->writeFieldBegin('location', TType::STRING, 3);
    $xfer += $output->writeString($self->{location});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ip_address}) {
    $xfer += $output->writeFieldBegin('ip_address', TType::STRING, 4);
    $xfer += $output->writeString($self->{ip_address});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hostname}) {
    $xfer += $output->writeFieldBegin('hostname', TType::STRING, 5);
    $xfer += $output->writeString($self->{hostname});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ColumnFamilyOptions;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ColumnFamilyOptions->mk_accessors( qw( max_versions ttl time_order_desc counter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{max_versions} = undef;
  $self->{ttl} = undef;
  $self->{time_order_desc} = undef;
  $self->{counter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{max_versions}) {
      $self->{max_versions} = $vals->{max_versions};
    }
    if (defined $vals->{ttl}) {
      $self->{ttl} = $vals->{ttl};
    }
    if (defined $vals->{time_order_desc}) {
      $self->{time_order_desc} = $vals->{time_order_desc};
    }
    if (defined $vals->{counter}) {
      $self->{counter} = $vals->{counter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnFamilyOptions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{max_versions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{ttl});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{time_order_desc});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{counter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnFamilyOptions');
  if (defined $self->{max_versions}) {
    $xfer += $output->writeFieldBegin('max_versions', TType::I32, 1);
    $xfer += $output->writeI32($self->{max_versions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ttl}) {
    $xfer += $output->writeFieldBegin('ttl', TType::I32, 2);
    $xfer += $output->writeI32($self->{ttl});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{time_order_desc}) {
    $xfer += $output->writeFieldBegin('time_order_desc', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{time_order_desc});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter}) {
    $xfer += $output->writeFieldBegin('counter', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{counter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ColumnFamilySpec;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ColumnFamilySpec->mk_accessors( qw( name access_group deleted generation id value_index qualifier_index options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{access_group} = undef;
  $self->{deleted} = undef;
  $self->{generation} = undef;
  $self->{id} = undef;
  $self->{value_index} = undef;
  $self->{qualifier_index} = undef;
  $self->{options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{access_group}) {
      $self->{access_group} = $vals->{access_group};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{generation}) {
      $self->{generation} = $vals->{generation};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value_index}) {
      $self->{value_index} = $vals->{value_index};
    }
    if (defined $vals->{qualifier_index}) {
      $self->{qualifier_index} = $vals->{qualifier_index};
    }
    if (defined $vals->{options}) {
      $self->{options} = $vals->{options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnFamilySpec';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{access_group});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{generation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{value_index});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{qualifier_index});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{options} = new Hypertable::ThriftGen::ColumnFamilyOptions();
        $xfer += $self->{options}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnFamilySpec');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{access_group}) {
    $xfer += $output->writeFieldBegin('access_group', TType::STRING, 2);
    $xfer += $output->writeString($self->{access_group});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{generation}) {
    $xfer += $output->writeFieldBegin('generation', TType::I64, 4);
    $xfer += $output->writeI64($self->{generation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 5);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value_index}) {
    $xfer += $output->writeFieldBegin('value_index', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{value_index});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier_index}) {
    $xfer += $output->writeFieldBegin('qualifier_index', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{qualifier_index});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{options}) {
    $xfer += $output->writeFieldBegin('options', TType::STRUCT, 8);
    $xfer += $self->{options}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::AccessGroupOptions;
use base qw(Class::Accessor);
Hypertable::ThriftGen::AccessGroupOptions->mk_accessors( qw( replication blocksize compressor bloom_filter in_memory ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{replication} = undef;
  $self->{blocksize} = undef;
  $self->{compressor} = undef;
  $self->{bloom_filter} = undef;
  $self->{in_memory} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{replication}) {
      $self->{replication} = $vals->{replication};
    }
    if (defined $vals->{blocksize}) {
      $self->{blocksize} = $vals->{blocksize};
    }
    if (defined $vals->{compressor}) {
      $self->{compressor} = $vals->{compressor};
    }
    if (defined $vals->{bloom_filter}) {
      $self->{bloom_filter} = $vals->{bloom_filter};
    }
    if (defined $vals->{in_memory}) {
      $self->{in_memory} = $vals->{in_memory};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AccessGroupOptions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{replication});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{blocksize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compressor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{bloom_filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{in_memory});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AccessGroupOptions');
  if (defined $self->{replication}) {
    $xfer += $output->writeFieldBegin('replication', TType::I16, 1);
    $xfer += $output->writeI16($self->{replication});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blocksize}) {
    $xfer += $output->writeFieldBegin('blocksize', TType::I32, 2);
    $xfer += $output->writeI32($self->{blocksize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressor}) {
    $xfer += $output->writeFieldBegin('compressor', TType::STRING, 3);
    $xfer += $output->writeString($self->{compressor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bloom_filter}) {
    $xfer += $output->writeFieldBegin('bloom_filter', TType::STRING, 4);
    $xfer += $output->writeString($self->{bloom_filter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{in_memory}) {
    $xfer += $output->writeFieldBegin('in_memory', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{in_memory});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::AccessGroupSpec;
use base qw(Class::Accessor);
Hypertable::ThriftGen::AccessGroupSpec->mk_accessors( qw( name generation options defaults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{generation} = undef;
  $self->{options} = undef;
  $self->{defaults} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{generation}) {
      $self->{generation} = $vals->{generation};
    }
    if (defined $vals->{options}) {
      $self->{options} = $vals->{options};
    }
    if (defined $vals->{defaults}) {
      $self->{defaults} = $vals->{defaults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AccessGroupSpec';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{generation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{options} = new Hypertable::ThriftGen::AccessGroupOptions();
        $xfer += $self->{options}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaults} = new Hypertable::ThriftGen::ColumnFamilyOptions();
        $xfer += $self->{defaults}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AccessGroupSpec');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{generation}) {
    $xfer += $output->writeFieldBegin('generation', TType::I64, 2);
    $xfer += $output->writeI64($self->{generation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{options}) {
    $xfer += $output->writeFieldBegin('options', TType::STRUCT, 3);
    $xfer += $self->{options}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaults}) {
    $xfer += $output->writeFieldBegin('defaults', TType::STRUCT, 4);
    $xfer += $self->{defaults}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::Schema;
use base qw(Class::Accessor);
Hypertable::ThriftGen::Schema->mk_accessors( qw( access_groups column_families generation version group_commit_interval access_group_defaults column_family_defaults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{access_groups} = undef;
  $self->{column_families} = undef;
  $self->{generation} = undef;
  $self->{version} = undef;
  $self->{group_commit_interval} = undef;
  $self->{access_group_defaults} = undef;
  $self->{column_family_defaults} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{access_groups}) {
      $self->{access_groups} = $vals->{access_groups};
    }
    if (defined $vals->{column_families}) {
      $self->{column_families} = $vals->{column_families};
    }
    if (defined $vals->{generation}) {
      $self->{generation} = $vals->{generation};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
    if (defined $vals->{group_commit_interval}) {
      $self->{group_commit_interval} = $vals->{group_commit_interval};
    }
    if (defined $vals->{access_group_defaults}) {
      $self->{access_group_defaults} = $vals->{access_group_defaults};
    }
    if (defined $vals->{column_family_defaults}) {
      $self->{column_family_defaults} = $vals->{column_family_defaults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size49 = 0;
          $self->{access_groups} = {};
          my $_ktype50 = 0;
          my $_vtype51 = 0;
          $xfer += $input->readMapBegin(\$_ktype50, \$_vtype51, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $key54 = '';
            my $val55 = new Hypertable::ThriftGen::AccessGroupSpec();
            $xfer += $input->readString(\$key54);
            $val55 = new Hypertable::ThriftGen::AccessGroupSpec();
            $xfer += $val55->read($input);
            $self->{access_groups}->{$key54} = $val55;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size56 = 0;
          $self->{column_families} = {};
          my $_ktype57 = 0;
          my $_vtype58 = 0;
          $xfer += $input->readMapBegin(\$_ktype57, \$_vtype58, \$_size56);
          for (my $_i60 = 0; $_i60 < $_size56; ++$_i60)
          {
            my $key61 = '';
            my $val62 = new Hypertable::ThriftGen::ColumnFamilySpec();
            $xfer += $input->readString(\$key61);
            $val62 = new Hypertable::ThriftGen::ColumnFamilySpec();
            $xfer += $val62->read($input);
            $self->{column_families}->{$key61} = $val62;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{generation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{group_commit_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{access_group_defaults} = new Hypertable::ThriftGen::AccessGroupOptions();
        $xfer += $self->{access_group_defaults}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_family_defaults} = new Hypertable::ThriftGen::ColumnFamilyOptions();
        $xfer += $self->{column_family_defaults}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{access_groups}) {
    $xfer += $output->writeFieldBegin('access_groups', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{access_groups}}));
      {
        while( my ($kiter63,$viter64) = each %{$self->{access_groups}}) 
        {
          $xfer += $output->writeString($kiter63);
          $xfer += ${viter64}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_families}) {
    $xfer += $output->writeFieldBegin('column_families', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{column_families}}));
      {
        while( my ($kiter65,$viter66) = each %{$self->{column_families}}) 
        {
          $xfer += $output->writeString($kiter65);
          $xfer += ${viter66}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{generation}) {
    $xfer += $output->writeFieldBegin('generation', TType::I64, 3);
    $xfer += $output->writeI64($self->{generation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::I32, 4);
    $xfer += $output->writeI32($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_commit_interval}) {
    $xfer += $output->writeFieldBegin('group_commit_interval', TType::I32, 5);
    $xfer += $output->writeI32($self->{group_commit_interval});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{access_group_defaults}) {
    $xfer += $output->writeFieldBegin('access_group_defaults', TType::STRUCT, 6);
    $xfer += $self->{access_group_defaults}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_family_defaults}) {
    $xfer += $output->writeFieldBegin('column_family_defaults', TType::STRUCT, 7);
    $xfer += $self->{column_family_defaults}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientException->mk_accessors( qw( code message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{code} = undef;
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{code}) {
      $self->{code} = $vals->{code};
    }
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{code});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientException');
  if (defined $self->{code}) {
    $xfer += $output->writeFieldBegin('code', TType::I32, 1);
    $xfer += $output->writeI32($self->{code});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
